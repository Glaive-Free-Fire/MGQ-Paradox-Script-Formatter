<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>RB_Script_AutoFormatter</title>
    <style>
        body { margin: 20px; font-family: Arial, sans-serif; }
        .header { text-align: center; margin-bottom: 20px; }
        .lang-controls { text-align: center; margin-bottom: 20px; }
        .lang-btn {
            padding: 5px 10px;
            margin: 0 5px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #f0f0f0;
        }
        .lang-btn.active {
            background: #fff;
            border-bottom: 2px solid #000;
        }
        .container { display: flex; gap: 20px; margin-top: 20px; }
        .editor, .output { flex: 1; }
        textarea { width: 100%; height: 300px; padding: 10px; }
        .output-content { 
            border: 1px solid #ccc; 
            padding: 10px; 
            height: 300px; 
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .controls { 
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .length-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .length-btn {
            padding: 5px 10px;
            min-width: 30px;
        }
		.tabs { 
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
        }
        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .tab-btn.active {
            background: #fff;
            border-bottom: 2px solid #000;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>RB_Script_AutoFormatter</h1>
    </div>

    <!-- Вкладки -->
    <div class="tabs">
        <button class="tab-btn active" data-mode="library">Library(Enemy)</button>
        <button class="tab-btn" data-mode="jobchange">JobChange</button>
    </div>

    <!-- Кнопки выбора языка -->
    <div class="lang-controls">
        <button class="lang-btn active" id="btn-rus">RUS</button>
        <button class="lang-btn" id="btn-jap">JAP</button>
    </div>

    <div class="container">
        <div class="editor">
            <h3>Ввод данных:</h3>
            <textarea id="input-data" placeholder="Введите текст с описанием..."></textarea>
        </div>
        <div class="output">
            <h3>Результат:</h3>
            <div id="output-content" class="output-content"></div>
        </div>
    </div>

    <div class="controls">
        <div class="length-control">
            <span>ДЛИНА СТРОКИ:</span>
            <button class="length-btn" id="decrease-length">-</button>
            <span id="current-length"></span>
            <button class="length-btn" id="increase-length">+</button>
        </div>
        <button id="copy-btn">Копировать результат</button>
        <button id="clear-btn">Исправить</button>
        <button id="report-btn">Репорт</button>


    </div>

<script>
  // Глобальные переменные для всех режимов
  let currentMode = "RUS"; // Текущий язык
  let currentTab = "library"; // Текущая вкладка
  let maxLineLengthRus = 39;
  let maxLineLengthJap = 22;
  let maxLineLengthJobChangeVar = 30; // Лимит строки для JobChange
  let isFormatted = false; // Флаг исправленного форматирования

  // Префиксы для иллюстрации
  const illustrationPrefixRUS = "Иллюстрация:";
  const illustrationPrefixJAP = "イラスト：";

  // Переключение вкладок
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentTab = btn.getAttribute('data-mode');
      isFormatted = false; // Сброс флага исправленного форматирования
      updateOutput();
    });
  });

  // Обработчики кнопок выбора языка
  const btnRus = document.getElementById('btn-rus');
  const btnJap = document.getElementById('btn-jap');
  btnRus.addEventListener('click', () => {
    currentMode = "RUS";
    btnRus.classList.add('active');
    btnJap.classList.remove('active');
    updateOutput();
  });
  btnJap.addEventListener('click', () => {
    currentMode = "JAP";
    btnJap.classList.add('active');
    btnRus.classList.remove('active');
    updateOutput();
  });

  // Обработчик ввода данных
  const inputEl = document.getElementById('input-data');
  inputEl.addEventListener('input', updateOutput);

  // Обработчик кнопок изменения длины строки (единая версия для всех режимов)
  document.getElementById('decrease-length').addEventListener('click', decreaseLength);
  document.getElementById('increase-length').addEventListener('click', increaseLength);
  document.getElementById('copy-btn').addEventListener('click', () => {
    navigator.clipboard.writeText(document.getElementById('output-content').textContent)
      .then(() => alert('Текст скопирован!'))
      .catch(err => console.error('Ошибка копирования:', err));
  });
  document.getElementById('clear-btn').addEventListener('click', fixFormatting);

// Глобальный массив для хранения логов ошибок
let errorLogs = [];

// Функция для форматирования текущей даты и времени
function getCurrentTimestamp() {
  const now = new Date();
  return now.toLocaleString();
}

// Функция для записи ошибки в лог
function logError(message, source, lineno, colno, error) {
  const timestamp = getCurrentTimestamp();
  const errorMessage = `[${timestamp}] Error: ${message} at ${source}:${lineno}:${colno}\n`;
  const errorStack = error && error.stack ? error.stack + "\n" : "";
  errorLogs.push(errorMessage + errorStack);
  console.error(errorMessage, error);
}

// Глобальный обработчик ошибок
window.onerror = function(message, source, lineno, colno, error) {
  logError(message, source, lineno, colno, error);
  return true;
};

// Функция для генерации лога и скачивания файла Log.txt
function generateErrorLog() {
  try {
    if (errorLogs.length === 0) {
      errorLogs.push(`[${getCurrentTimestamp()}] No errors reported.\n`);
    }
    const logText = errorLogs.join('\n');
    const blob = new Blob([logText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'Log.txt';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (e) {
    logError(e.message, "generateErrorLog", e.lineNumber, e.columnNumber, e);
  }
}

  function initEventListeners() {
      const addListener = (id, event, handler) => {
          const el = document.getElementById(id);
          if(el) el.addEventListener(event, handler);
          else console.error(`Element #${id} not found`);
      };

      addListener('decrease-length', 'click', () => adjustLength(-1));
      addListener('increase-length', 'click', () => adjustLength(1));
      addListener('copy-btn', 'click', copyToClipboard);
      addListener('clear-btn', 'click', cleanOutput);
      addListener('report-btn', 'click', generateErrorLog);
  }

  // Функция копирования в буфер
  function copyToClipboard() {
      navigator.clipboard.writeText(document.getElementById('output-content').textContent)
          .then(() => alert('Текст скопирован!'))
          .catch(err => console.error('Ошибка копирования:', err));
  }

  // Привязываем обработчик для кнопки "Репорт" после загрузки DOM
  document.addEventListener("DOMContentLoaded", function() {
      initEventListeners();
      updateOutput();
  });

  // Call this at page load
  document.addEventListener('DOMContentLoaded', function() {
      setupEventListeners();
      console.log("Initial setup complete");
  });

  // Остальной код (обработка блоков, изменение длины строки, форматирование и т.д.) остается без изменений.
  // Пример: функция cleanOutput обёрнута в try/catch для логирования ошибок

  function cleanOutput() {
      const outputEl = document.getElementById('output-content');
      try {
          let content = outputEl.textContent
              .replace(/"\s*],/g, '"\n  ],')
              .replace(/\],\n\s+\[/g, '],\n  [')
              .replace(/(\d+ => \[)\n\s+\[/g, '$1\n  [[')
              .replace(/(\s{2}\][^\n]*)\n\s+(\][^\n]*)/g, '$1$2')
              .replace(/\[\[\n\s+\[/g, '[[\n  [')
              .replace(/"\s+\[/g, '", [');

          outputEl.textContent = content
              .split('\n')
              .map(line => line.trim().startsWith('"') 
                  ? line.replace(/^\s+/, '    ') 
                  : line
              )
              .join('\n');
          
          isFormatted = true;
      } catch(e) {
          logError(e.message, "cleanOutput", e.lineNumber, e.columnNumber, e);
      }
  }


  // Пример использования: оборачиваем функцию очистки вывода в try/catch
  function cleanOutput() {
    try {
      const outputEl = document.getElementById('output-content');
      let lines = outputEl.textContent.split('\n');
      let newLines = [];
      let inBlock = false;
      let prevLine = '';
      
      // Track categories and indentation states
      const categories = ["Экипировка:", "Навыки:", "Способности:"];
      let currentCategory = "";
      const indent = "			   "; // Standard indentation for continuation lines
      
      for(let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmedLine = line.trim();
        
        // Check if we're at the start or end of a block
        if(trimmedLine === '[[') {
            newLines.push(line);
            inBlock = true;
            i++; // Skip the next line after [[
            continue;
        }
        
        if(trimmedLine === ']],') {
            if(prevLine.trim() === '],') {
                newLines.pop(); // Remove the second-to-last line before ]],
            }
            newLines.push(line);
            inBlock = false;
            currentCategory = "";
            continue;
        }
        
        if(inBlock) prevLine = line;
        
        // Check if line contains a category
        let isCategoryLine = false;
        for(let category of categories) {
            if(trimmedLine.startsWith(category)) {
                currentCategory = category;
                isCategoryLine = true;
                break;
            }
        }
        
        // Process the line based on content type
        if(isCategoryLine) {
            // This is a category header line - clean it but keep as is
            let cleanedLine = trimmedLine.replace(/\s*　\s*/g, '　');
            newLines.push(cleanedLine);
            
        } else if(currentCategory && !isCategoryLine) {
            // This is a continuation of a category - apply indentation
            
            // If line starts with wide space or has indentation already
            let content = trimmedLine;
            if(content.startsWith('　')) {
                content = content.substring(1);
            }
            
            // Clean spaces around wide spaces
            content = content.replace(/\s*　\s*/g, '　');
            
            // Apply proper indentation
            newLines.push(indent + content);
            
        } else {
            // Regular line - just clean it
            let cleanedLine = trimmedLine.replace(/\s*　\s*/g, '　');
            newLines.push(cleanedLine);
        }
      }
      
      outputEl.textContent = newLines.join('\n');
      isFormatted = true;
    } catch (e) {
      logError(e.message, "cleanOutput", e.lineNumber, e.columnNumber, e);
    }
  }


  // Единая функция изменения длины строки, учитывающая текущую вкладку
  function adjustLength(delta) {
    if (currentTab === "jobchange") {
      maxLineLengthJobChangeVar = Math.max(10, maxLineLengthJobChangeVar + delta);
    } else if (currentMode === "JAP") {
      maxLineLengthJap = Math.max(10, maxLineLengthJap + delta);
    } else {
      maxLineLengthRus = Math.max(10, maxLineLengthRus + delta);
    }

  // Если формат уже исправлен, корректируем перед обновлением
    if (isFormatted) {
      fixFormatting();
    }

    updateOutput(); // Вызываем обновление после исправления
  }


  // Единая функция обновления отображения длины строки
  function updateLengthDisplay() {
    let len;
    if (currentTab === "jobchange") {
      len = maxLineLengthJobChangeVar;
    } else {
      len = currentMode === "JAP" ? maxLineLengthJap : maxLineLengthRus;
    }
    document.getElementById('current-length').textContent = len;
  }

  // Единая функция обновления вывода
  // Функция обновления вывода
  function updateOutput() {
    updateLengthDisplay();
    const inputText = document.getElementById('input-data').value;
    if (!inputText.trim()) {
      document.getElementById('output-content').textContent = '';
      return;
    }
    try {
      let output = currentTab === "library" ? processText(inputText) : processJobChangeText(inputText);
      document.getElementById('output-content').textContent = output;
    } catch (e) {
      document.getElementById('output-content').textContent = 'Ошибка форматирования';
    }
  }

  // Функция обработки JobChange
  function processJobChangeText(text) {
    try {
      // Parse input into blocks
      let lines = text.split('\n');
      let blocks = [];
      let currentBlock = null;
      
      for (let line of lines) {
        if (line.trim().match(/^\d+\s*#/)) {
          if (currentBlock) blocks.push(currentBlock);
          currentBlock = { 
            header: line.trim(), 
            description: [],
            equipment: [],
            skills: [],
            abilities: []
          };
        } else if (currentBlock) {
          // Add line to appropriate section based on content
          const trimmedLine = line.trim();
          if (!trimmedLine) continue;
          
          if (trimmedLine.startsWith("Экипировка:")) {
            currentBlock.equipment.push(trimmedLine);
          } else if (trimmedLine.startsWith("Навыки:")) {
            currentBlock.skills.push(trimmedLine);
          } else if (trimmedLine.startsWith("Способности:")) {
            currentBlock.abilities.push(trimmedLine);
          } else if (currentBlock.abilities.length > 0) {
            // Continuation of abilities section
            currentBlock.abilities.push(trimmedLine);
          } else if (currentBlock.skills.length > 0) {
            // Continuation of skills section
            currentBlock.skills.push(trimmedLine);
          } else if (currentBlock.equipment.length > 0) {
            // Continuation of equipment section
            currentBlock.equipment.push(trimmedLine);
          } else {
            // This is part of the description
            currentBlock.description.push(trimmedLine);
          }
        }
      }
      
      if (currentBlock) blocks.push(currentBlock);
      
      let result = "";
      blocks.forEach(block => {
        // Skip blocks without Russian characters if in RUS mode
        let blockText = block.header + "\n" + 
                       block.description.join("\n") + "\n" +
                       block.equipment.join("\n") + "\n" +
                       block.skills.join("\n") + "\n" +
                       block.abilities.join("\n");
                       
        if (currentMode === "RUS" && !/[А-Яа-яЁё]/.test(blockText)) return;
        if (currentMode === "JAP" && !/[\u3040-\u30FF\u4E00-\u9FBF]/.test(blockText)) return;
        
        // Extract ID and title
        let headerParts = block.header.split('#');
        let id = headerParts[0].trim();
        let title = headerParts.length > 1 ? '# ' + headerParts[1].trim() : '';
        
        // Format description
        let formattedDescription = [];
        if (block.description.length > 0) {
          let descText = block.description.join(' ');
          formattedDescription = wrapText(descText, maxLineLengthJobChangeVar, currentMode);
        }
        
        // Format equipment, skills and abilities
        let formattedEquipment = formatCategory("Экипировка:", block.equipment, maxLineLengthJobChangeVar);
        let formattedSkills = formatCategory("Навыки:", block.skills, maxLineLengthJobChangeVar);
        let formattedAbilities = formatCategory("Способности:", block.abilities, maxLineLengthJobChangeVar);
        
        // Build result
        result += `${id} => ${title}\n  [[\n`;
        
        // Description section
        formattedDescription.forEach(line => {
          result += `    "${escapeQuotes(line)}",\n`;
        });
        
        // SAVE marker
        result += "SAVE\n";
        
        // Equipment, skills and abilities sections
        formattedEquipment.forEach(line => {
          result += `    "${escapeQuotes(line)}",\n`;
        });
        
        formattedSkills.forEach(line => {
          result += `    "${escapeQuotes(line)}",\n`;
        });
        
        formattedAbilities.forEach(line => {
          result += `    "${escapeQuotes(line)}",\n`;
        });
        
        result += "  ]],\n";
      });
      
      return result;
    } catch (e) {
      console.error("Error in processJobChangeText:", e);
      return "Error processing text: " + e.message;
    }
  }

  // New function to specifically handle equipment, skills, and abilities
  function processEquipmentSection(equipmentLines, maxLineLength) {
    try {
      const categories = ["Экипировка:", "Навыки:", "Способность:"];
      let result = [];
      
      // Group content by categories
      let categoryContent = {};
      let currentCategory = null;
      
      for (let i = 0; i < equipmentLines.length; i++) {
        let line = equipmentLines[i].trim();
        
        // Check if this line starts a new category
        let foundCategory = false;
        for (let category of categories) {
          // Check if line starts with a category OR contains a category after space/separator
          if (line.startsWith(category)) {
            // Line starts with a category
            currentCategory = category;
            categoryContent[currentCategory] = line.substring(category.length).trim();
            foundCategory = true;
            break;
          } else if (line.includes(category)) {
            // Line contains a category in the middle - split it
            let parts = line.split(category);
            
            // Handle the first part (belongs to previous category)
            if (currentCategory) {
              categoryContent[currentCategory] += " " + parts[0].trim();
            }
            
            // Set up the new category
            currentCategory = category;
            categoryContent[currentCategory] = parts[1].trim();
            foundCategory = true;
            break;
          }
        }
        
        if (!foundCategory && currentCategory) {
          categoryContent[currentCategory] += " " + line;
        }
      }
      
      // Process each category
      for (let category of categories) {
        if (!categoryContent[category]) continue;
        
        let itemsText = categoryContent[category];
        // Split by wide spaces
        let items = itemsText.split('　').filter(Boolean);
        
        let currentLine = category;
        const indent = "			   "; // Standard indentation
        
        // First item gets a space after category name
        if (items.length > 0) {
          currentLine += " " + items[0] + "　";
          items = items.slice(1);
        }
        
        for (let item of items) {
          if ((currentLine.length + item.length + 1) <= maxLineLength) {
            currentLine += item + "　";
          } else {
            // Remove trailing wide space
            if (currentLine.endsWith("　")) {
              currentLine = currentLine.slice(0, -1);
            }
            result.push(currentLine);
            currentLine = indent + item + "　";
          }
        }
        
        // Add the last line
        if (currentLine !== category && currentLine !== indent) {
          if (currentLine.endsWith("　")) {
            currentLine = currentLine.slice(0, -1);
          }
          result.push(currentLine);
        }
      }
      
      return result;
    } catch (e) {
      console.error("Error in processEquipmentSection:", e);
      return equipmentLines; // Return original lines as fallback
    }
  }

  // Improved function to format specific categories
  function formatCategory(categoryName, lines, maxLineLength) {
    try {
      if (!lines || lines.length === 0) return [];
      
      const indent = "			   "; // Standard indentation
      let result = [];
      let items = [];
      
      // Extract items from all lines
      lines.forEach(line => {
        let content = line.trim();
        if (content.startsWith(categoryName)) {
          content = content.substring(categoryName.length).trim();
        }
        
        // Split by wide space and add to items
        content.split('　').filter(Boolean).forEach(item => {
          items.push(item);
        });
      });
      
      if (items.length === 0) {
        // If there are no items but we have lines, just add "Нет" for abilities
        if (categoryName === "Способности:" && lines[0].trim() === "Способности: Нет") {
          return ["Способности: Нет"];
        }
        return [];
      }
      
      // Start with category name
      let currentLine = categoryName + " " + items[0];
      let lineIndex = 1;
      
      // Process remaining items
      while (lineIndex < items.length) {
        const item = items[lineIndex];
        
        // Check if adding this item would exceed the line length
        if ((currentLine.length + 1 + item.length + 1) <= maxLineLength) {
          currentLine += "　" + item;
        } else {
          // Current line is full, add it to results
          result.push(currentLine);
          currentLine = indent + item;
        }
        
        lineIndex++;
      }
      
      // Add the last line if not empty
      if (currentLine && currentLine !== (categoryName + " ") && currentLine !== indent) {
        result.push(currentLine);
      }
      
      return result;
    } catch (e) {
      console.error("Error in formatCategory:", e);
      return [categoryName + " Error"];
    }
  }




  // Функция wrapText (перенос строк)
  function wrapText(text, maxLen, lang) {
    try {
      if (lang === "JAP") {
        // Japanese text: break by characters
        let lines = [];
        for (let i = 0; i < text.length; i += maxLen) {
          lines.push(text.substr(i, maxLen));
        }
        return lines;
      } else {
        // Russian text processing
        const words = text.split(' ');
        let lines = [];
        let currentLine = '';
        
        for (let word of words) {
          if ((currentLine.length ? currentLine.length + 1 : 0) + word.length <= maxLen) {
            currentLine += (currentLine ? ' ' : '') + word;
          } else {
            lines.push(currentLine);
            currentLine = word;
          }
        }
        
        if (currentLine) {
          lines.push(currentLine);
        }
        
        return lines;
      }
    } catch (e) {
      console.error("Error in wrapText:", e);
      return [text]; // Return original text as fallback
    }
  }

    

  // Функция экранирования кавычек в строке
  function escapeQuotes(str) {
    return str.replace(/"/g, '\\"');
  }

  // Функция обработки для вкладки Library (без изменений)
  function processText(text) {
    let lines = text.split('\n');
    let blocks = [];
    let currentBlock = null;
    for (let line of lines) {
      if (line.trim().match(/^\d+$/)) { // новая метка блока
        if (currentBlock) {
          blocks.push(currentBlock);
        }
        currentBlock = { id: line.trim(), content: [] };
      } else {
        if (currentBlock) {
          currentBlock.content.push(line);
        }
      }
    }
    if (currentBlock) {
      blocks.push(currentBlock);
    }
    return blocks.map(block => processBlock(block)).join('\n');
  }

  // Функция для проверки строки на наличие символов нужного языка
  function isLineInActiveLang(line) {
    if (currentMode === "RUS") {
      return /[А-Яа-яЁё]/.test(line);
    } else if (currentMode === "JAP") {
      return /[\u3040-\u30FF\u4E00-\u9FBF]/.test(line);
    }
    return false;
  }

  // Обрабатывает отдельный блок для Library
  function processBlock(block) {
      let outputLines = [];
      let illustrationLine = "";
      
      function addLine(line) {
          if (line === "") {
              if (outputLines.length === 0 || outputLines[outputLines.length - 1] !== "") {
                  outputLines.push("");
              }
          } else {
              outputLines.push(line);
          }
      }
      
      block.content.forEach(line => {
          if (line.trim() === "") {
              addLine("");
              return;
          }
          if (line.trim().match(/^Иллюстрация[:：]/)) {
              illustrationLine = line.trim();
              return;
          }
          if (isLineInActiveLang(line)) {
              let splitted = splitIntoLines(line, getCurrentMaxLineLength());
              splitted.forEach(subLine => addLine(subLine));
          }
      });
      
      if (illustrationLine) {
          illustrationLine = illustrationLine.replace(/^Иллюстрация[:：]\s*/, "");
          if (currentMode === "JAP") {
              illustrationLine = illustrationPrefixJAP + illustrationLine;
          } else {
              illustrationLine = illustrationPrefixRUS + " " + illustrationLine;
          }
          addLine("");
          addLine(illustrationLine);
      }
      
      let formatted = outputLines.map(line => `    "${escapeQuotes(line)}",`).join('\n');
      // Исправлено формирование структуры блоков
      return `${block.id} => [\n${formatted}\n],`;
  }

  // Разбивка текста на строки с учётом максимальной длины для Library
  function splitIntoLines(text, maxLen) {
    if (currentMode === "JAP") {
      let lines = [];
      for (let i = 0; i < text.length; i += maxLen) {
        lines.push(text.substr(i, maxLen));
      }
      return lines;
    } else {
      const words = text.replace(/\n/g, ' ').split(' ').filter(Boolean);
      let lines = [];
      let currentLine = '';
      words.forEach(word => {
        if ((currentLine.length ? currentLine.length + 1 : 0) + word.length > maxLen) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine += (currentLine ? ' ' : '') + word;
        }
      });
      if (currentLine) lines.push(currentLine);
      return lines;
    }
  }

  // Возвращает текущую максимальную длину строки для выбранного языка (для Library)
  function getCurrentMaxLineLength() {
    return currentMode === "JAP" ? maxLineLengthJap : maxLineLengthRus;
  }

  function fixFormatting() {
      try {
          const outputEl = document.getElementById('output-content');
          let content = outputEl.textContent;
          
          // Replace SAVE marker with proper section separator
          content = content.replace(/SAVE/g, '  ],\n  [');
          
          // Fix any other formatting issues
          let lines = content.split('\n');
          let result = [];
          
          for (let i = 0; i < lines.length; i++) {
              let line = lines[i].trim();
              
              // Skip empty lines
              if (line === '') continue;
              
              // Process lines based on content
              if (line.match(/^\d+\s*=>\s*#/)) {
                  // Block header - add as is
                  result.push(line);
              } else if (line === '[[') {
                  // Block start - add with proper indentation
                  result.push('  [[');
              } else if (line === ']],') {
                  // Block end - add with proper indentation
                  result.push('  ]],');
              } else if (line.startsWith('"')) {
                  // Quoted line - add with proper indentation
                  result.push('    ' + line);
              } else if (line === '],') {
                  // Section end - add with proper indentation
                  result.push('  ],');
              } else if (line === '[') {
                  // Section start - add with proper indentation
                  result.push('  [');
              } else {
                  // Other lines - add as is
                  result.push(line);
              }
          }
          
          outputEl.textContent = result.join('\n');
          isFormatted = true;
      } catch (e) {
          console.error("Error in fixFormatting:", e);
          alert("Error in fixFormatting: " + e.message);
      }
  }

  function decreaseLength() {
      adjustLength(-1);
  }

  function increaseLength() {
      adjustLength(1);
  }

  // Изменение длины строки (и сохранение формата)
  function adjustLength(delta) {
      console.log("Adjusting length with delta:", delta); // Debugging
      
      // Get current value before adjustment
      let oldValue;
      if (currentTab === "jobchange") {
          oldValue = maxLineLengthJobChangeVar;
          maxLineLengthJobChangeVar = Math.max(10, maxLineLengthJobChangeVar + delta);
          console.log(`JobChange line length: ${oldValue} → ${maxLineLengthJobChangeVar}`);
      } else if (currentMode === "JAP") {
          oldValue = maxLineLengthJap;
          maxLineLengthJap = Math.max(10, maxLineLengthJap + delta);
          console.log(`JAP line length: ${oldValue} → ${maxLineLengthJap}`);
      } else {
          oldValue = maxLineLengthRus;
          maxLineLengthRus = Math.max(10, maxLineLengthRus + delta);
          console.log(`RUS line length: ${oldValue} → ${maxLineLengthRus}`);
      }
      
      // Update UI and output
      updateLengthDisplay();
      updateOutput();
  }

  // Clean implementation of handlers to prevent multiple triggers
  function setupEventListeners() {
      // First remove any existing listeners
      const decreaseBtn = document.getElementById('decrease-length');
      const increaseBtn = document.getElementById('increase-length');
      
      // Clone and replace buttons to remove all listeners
      const newDecreaseBtn = decreaseBtn.cloneNode(true);
      const newIncreaseBtn = increaseBtn.cloneNode(true);
      
      decreaseBtn.parentNode.replaceChild(newDecreaseBtn, decreaseBtn);
      increaseBtn.parentNode.replaceChild(newIncreaseBtn, increaseBtn);
      
      // Add single listeners with direct delta values
      newDecreaseBtn.addEventListener('click', function(e) {
          e.stopPropagation(); // Prevent bubbling
          adjustLength(-1);
      });
      
      newIncreaseBtn.addEventListener('click', function(e) {
          e.stopPropagation(); // Prevent bubbling
          adjustLength(1);
      });
      
      console.log("Event listeners set up");
  }

  // Event listeners
  document.getElementById('copy-btn').addEventListener('click', () => {
    navigator.clipboard.writeText(document.getElementById('output-content').textContent)
      .then(() => alert('Текст скопирован!'))
      .catch(err => console.error('Ошибка копирования:', err));
  });
  document.getElementById('clear-btn').addEventListener('click', fixFormatting);
  document.addEventListener("DOMContentLoaded", function () {
  const reportBtn = document.getElementById("report-btn");
  if (reportBtn) {
    reportBtn.addEventListener("click", generateErrorLog);
  } else {
    console.warn("Кнопка 'Репорт' (report-btn) не найдена в HTML!");
  }
});

  // Инициализация
  updateOutput();

// --- Упрощённая функция очистки вывода ---
  function cleanOutput() {
      const outputEl = document.getElementById('output-content');
      let lines = outputEl.textContent.split('\n');
      let newLines = [];
      let inBlock = false;
      let prevLine = '';
      
      // Track categories and indentation states
      const categories = ["Экипировка:", "Навыки:", "Способности:"];
      let currentCategory = "";
      const indent = "			   "; // Standard indentation for continuation lines
      
      for(let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const trimmedLine = line.trim();
          
          // Check if we're at the start or end of a block
          if(trimmedLine === '[[') {
              newLines.push(line);
              inBlock = true;
              i++; // Skip the next line after [[
              continue;
          }
          
          if(trimmedLine === ']],') {
              if(prevLine.trim() === '],') {
                  newLines.pop(); // Remove the second-to-last line before ]],
              }
              newLines.push(line);
              inBlock = false;
              currentCategory = "";
              continue;
          }
          
          if(inBlock) prevLine = line;
          
          // Check if line contains a category
          let isCategoryLine = false;
          for(let category of categories) {
              if(trimmedLine.startsWith(category)) {
                  currentCategory = category;
                  isCategoryLine = true;
                  break;
              }
          }
          
          // Process the line based on content type
          if(isCategoryLine) {
              // This is a category header line - clean it but keep as is
              let cleanedLine = trimmedLine.replace(/\s*　\s*/g, '　');
              newLines.push(cleanedLine);
              
          } else if(currentCategory && !isCategoryLine) {
              // This is a continuation of a category - apply indentation
              
              // If line starts with wide space or has indentation already
              let content = trimmedLine;
              if(content.startsWith('　')) {
                  content = content.substring(1);
              }
              
              // Clean spaces around wide spaces
              content = content.replace(/\s*　\s*/g, '　');
              
              // Apply proper indentation
              newLines.push(indent + content);
              
          } else {
              // Regular line - just clean it
              let cleanedLine = trimmedLine.replace(/\s*　\s*/g, '　');
              newLines.push(cleanedLine);
          }
      }
      
      outputEl.textContent = newLines.join('\n');
      isFormatted = true;
  }
</script>
</body>
</html>
