<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>RB_Script_AutoFormatter</title>
    <style>
        body { margin: 20px; font-family: Arial, sans-serif; }
        .header { text-align: center; margin-bottom: 20px; }
        .lang-controls { text-align: center; margin-bottom: 20px; }
        .lang-btn {
            padding: 5px 10px;
            margin: 0 5px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #f0f0f0;
        }
        .lang-btn.active {
            background: #fff;
            border-bottom: 2px solid #000;
        }
        .container { display: flex; gap: 20px; margin-top: 20px; }
        .editor, .output { flex: 1; }
        textarea { width: 100%; height: 300px; padding: 10px; }
        .output-content { 
            border: 1px solid #ccc; 
            padding: 10px; 
            height: 300px; 
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .controls { 
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .length-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .length-btn {
            padding: 5px 10px;
            min-width: 30px;
        }
        .tabs { 
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
        }
        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .tab-btn.active {
            background: #fff;
            border-bottom: 2px solid #000;
        }
        #skills-file-container {
            display: none;
            margin-top: 10px;
            align-items: center;
            gap: 10px;
            justify-content: center;
        }
        #process-skill-btn {
            display: none;
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        #process-skill-btn:hover {
            background: #388E3C;
        }
        #copy-btn, #compile-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #copy-btn {
            background: #6c757d;
            color: white;
        }
        #compile-btn {
            background: #4CAF50;
            color: white;
        }
        .compile-mode-btn {
            padding: 8px 16px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #4CAF50;
        }
        .compile-mode-btn.active {
            background-color: #f44336;
        }
        #button-container {
            display: flex;
            gap: 10px;
        }
        #status-message {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>RB_Script_AutoFormatter</h1>
    </div>

    <!-- Вкладки -->
    <div class="tabs">
        <button class="tab-btn active" data-mode="library">Library(Enemy)</button>
        <button class="tab-btn" data-mode="jobchange">JobChange</button>
        <button class="tab-btn" data-mode="medal">Library(Medal)</button>
        <button class="tab-btn" data-mode="skillreplacer">Skill Replacer</button>
    </div>

    <!-- Кнопки выбора языка -->
    <div class="lang-controls" id="lang-controls">
        <button class="lang-btn active" id="btn-rus">RUS</button>
        <button class="lang-btn" id="btn-jap">JAP</button>
    </div>

    <div class="container">
        <div class="editor">
            <h3>Ввод данных:</h3>
            <textarea id="input-data" placeholder="Введите текст с описанием..."></textarea>
        </div>
        <div class="output">
            <h3>Результат:</h3>
            <div id="output-content" class="output-content"></div>
        </div>
    </div>

    <div class="controls">
        <div class="length-control" id="length-control">
            <span>ДЛИНА СТРОКИ:</span>
            <button class="length-btn" id="decrease-length">-</button>
            <span id="current-length"></span>
            <button class="length-btn" id="increase-length">+</button>
        </div>
        <div id="button-container">
            <button id="copy-btn">Копировать результат</button>
            <button id="compile-btn" style="display: none;">Компилировать данные</button>
        </div>
        <button id="compile-mode-btn" class="compile-mode-btn">Режим прямой компиляции</button>
        
        <!-- Skill Replacer specific controls -->
        <div id="skills-file-container">
            <label>Файл Skills: </label>
            <input type="file" id="skills-file-input" accept=".txt">
            <button id="process-skill-btn">Обработать Skills</button>
        </div>
        
        <!-- Library Updater controls, скрыто, т.к. дублирует "Компилировать данные" -->
        <!-- <div id="library-updater-container" style="display: none; margin-top: 10px; align-items: center; gap: 10px; justify-content: center;">
            <label>Файл Library: </label>
            <input type="file" id="library-file" accept=".rb">
            <button id="update-library-button">Обновить библиотеку</button>
        </div> -->
    </div>
    


<script>
  // Глобальные переменные для всех режимов
  let currentMode = "RUS"; // Текущий язык
  let currentTab = "library"; // Текущая вкладка
  let maxLineLengthRus = 39;
  let maxLineLengthJap = 22;
  let maxLineLengthJobChangeVar = 30; // Лимит строки для JobChange
  let isFormatted = false; // Флаг исправленного форматирования
  let isCompileMode = false; // Режим прямой компиляции
  
  // Константы для имен файлов
  const FILE_NAMES = {
    "library": "201 - Library(Enemy).rb",
    "jobchange": "197 - JobChange.rb",
    "medal": "204 - Library(Medal).rb"
  };
  
  // Глобальные переменные для хранения информации о выбранном файле
  window.lastSelectedFileContent = null;
  window.lastSelectedFileName = null;

  // Префиксы для иллюстрации
  const illustrationPrefixRUS = "Иллюстрация：";
  const illustrationPrefixJAP = "イラスト：";

  // Переключение вкладок
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentTab = btn.getAttribute('data-mode');
      isFormatted = false; // Сброс флага исправленного форматирования
      
      // Показываем/скрываем элементы в зависимости от выбранной вкладки
      const skillsFileContainer = document.getElementById('skills-file-container');
      const lengthControlContainer = document.getElementById('length-control');
      const processSkillBtn = document.getElementById('process-skill-btn');
      const outputContainer = document.querySelector('.output');
      const copyBtn = document.getElementById('copy-btn');
      const langControls = document.getElementById('lang-controls');
      const compileModeBtn = document.getElementById('compile-mode-btn');
      // const libraryUpdaterContainer = document.getElementById('library-updater-container');
      
      if (currentTab === "skillreplacer") {
        // Скрываем ненужные элементы для вкладки Skill Replacer
        if (skillsFileContainer) skillsFileContainer.style.display = 'flex';
        if (processSkillBtn) processSkillBtn.style.display = 'inline-block';
        if (lengthControlContainer) lengthControlContainer.style.display = 'none';
        if (outputContainer) outputContainer.style.display = 'none';
        if (copyBtn) copyBtn.style.display = 'none';
        if (langControls) langControls.style.display = 'none'; // Скрываем выбор языка
        if (compileModeBtn) compileModeBtn.style.display = 'none'; // Скрываем кнопку режима компиляции
        // if (libraryUpdaterContainer) libraryUpdaterContainer.style.display = 'none'; // Скрываем управление библиотекой
      } else if (currentTab === "library") {
        // Показываем элементы управления библиотекой для вкладки Library(Enemy)
        if (skillsFileContainer) skillsFileContainer.style.display = 'none';
        if (processSkillBtn) processSkillBtn.style.display = 'none';
        if (lengthControlContainer) lengthControlContainer.style.display = 'flex';
        if (outputContainer) outputContainer.style.display = 'block';
        if (copyBtn) copyBtn.style.display = 'inline-block';
        if (langControls) langControls.style.display = 'block'; // Показываем выбор языка
        if (compileModeBtn) compileModeBtn.style.display = 'block'; // Показываем кнопку режима компиляции
        // if (libraryUpdaterContainer) libraryUpdaterContainer.style.display = 'flex'; // Показываем управление библиотекой
      } else {
        // Возвращаем отображение элементов для других вкладок
        if (skillsFileContainer) skillsFileContainer.style.display = 'none';
        if (processSkillBtn) processSkillBtn.style.display = 'none';
        if (lengthControlContainer) lengthControlContainer.style.display = 'flex';
        if (outputContainer) outputContainer.style.display = 'block';
        if (copyBtn) copyBtn.style.display = 'inline-block';
        if (langControls) langControls.style.display = 'block'; // Показываем выбор языка
        if (compileModeBtn) compileModeBtn.style.display = 'block'; // Показываем кнопку режима компиляции
        // if (libraryUpdaterContainer) libraryUpdaterContainer.style.display = 'none'; // Скрываем управление библиотекой
        updateOutput();
      }
    });
  });

  // Обработчики кнопок выбора языка
  const btnRus = document.getElementById('btn-rus');
  const btnJap = document.getElementById('btn-jap');
  btnRus.addEventListener('click', () => {
    currentMode = "RUS";
    btnRus.classList.add('active');
    btnJap.classList.remove('active');
    updateOutput();
  });
  btnJap.addEventListener('click', () => {
    currentMode = "JAP";
    btnJap.classList.add('active');
    btnRus.classList.remove('active');
    updateOutput();
  });

  // Обработчик ввода данных
  const inputEl = document.getElementById('input-data');
  inputEl.addEventListener('input', updateOutput);

  // Обработчик кнопок изменения длины строки
  document.getElementById('decrease-length').addEventListener('click', () => adjustLength(-1));
  document.getElementById('increase-length').addEventListener('click', () => adjustLength(1));
  document.getElementById('copy-btn').addEventListener('click', copyToClipboard);
  
  // Явно добавляем обработчик для кнопки Skill Replacer
  document.getElementById('process-skill-btn').addEventListener('click', processSkillReplacer);
  
  // Обработчик для кнопки режима компиляции
  document.getElementById('compile-mode-btn').addEventListener('click', toggleCompileMode);
  
  // Обработчик для кнопки компиляции данных
  document.getElementById('compile-btn').addEventListener('click', compileData);
  
  // Обработчик для кнопки обновления библиотеки
  // document.getElementById('update-library-button').addEventListener('click', updateLibraryFile);
  


  // Функция копирования в буфер
  function copyToClipboard() {
    navigator.clipboard.writeText(document.getElementById('output-content').textContent)
      .then(() => alert('Текст скопирован!'))
      .catch(err => console.error('Ошибка копирования:', err));
  }
  
  // Функция переключения режима компиляции
  function toggleCompileMode() {
    const compileModeBtn = document.getElementById('compile-mode-btn');
    const copyBtn = document.getElementById('copy-btn');
    const compileBtn = document.getElementById('compile-btn');
    
    isCompileMode = !isCompileMode;
    
    if (isCompileMode) {
      // Включаем режим компиляции
      compileModeBtn.textContent = 'Стандартный режим';
      compileModeBtn.classList.add('active');
      copyBtn.style.display = 'none';
      compileBtn.style.display = 'block';
      
      // Показываем инструкцию
      showInstructions();
    } else {
      // Выключаем режим компиляции
      compileModeBtn.textContent = 'Режим прямой компиляции';
      compileModeBtn.classList.remove('active');
      copyBtn.style.display = 'block';
      compileBtn.style.display = 'none';
      
      // Скрываем инструкции
      hideInstructions();
    }
  }
  
  // Функция для отображения инструкций
  function showInstructions() {
    let instructionsDiv = document.getElementById('compile-instructions');
    if (!instructionsDiv) {
      instructionsDiv = document.createElement('div');
      instructionsDiv.id = 'compile-instructions';
      instructionsDiv.className = 'compile-instructions';
      instructionsDiv.innerHTML = `
        <h3>Инструкция по использованию режима прямой компиляции</h3>
        <ol start="1">
          <li>Выберите нужную вкладку и подготовьте данные в окне вывода</li>
          <li>Выберите оригинальный файл Ruby через поле загрузки ниже</li>
          <li>Нажмите "Компилировать данные", чтобы создать обновленную версию файла</li>
        </ol>
        <div id="file-input-container" style="margin-top: 15px;">
          <label for="input-file">Выбрать оригинальный файл для обновления:</label>
          <input type="file" id="input-file" accept=".rb" style="margin-top: 5px;">
        </div>
        <div id="download-container" style="margin-top: 15px; display: none;">
          <a id="download-link" href="#" download="" class="download-button">Скачать обновленный файл</a>
        </div>
      `;
      
      document.querySelector('.container').insertAdjacentElement('afterend', instructionsDiv);
      
      // Добавляем стили для инструкций
      const styleElement = document.createElement('style');
      styleElement.textContent = `
        .compile-instructions {
          margin: 20px auto;
          padding: 15px;
          border: 1px solid #ccc;
          border-radius: 5px;
          background-color: #f8f9fa;
          max-width: 800px;
        }
        .compile-instructions h3 {
          margin-top: 0;
          color: #2c3e50;
        }
        .compile-instructions ol {
          padding-left: 20px;
        }
        .compile-instructions li {
          margin-bottom: 8px;
        }
        .compile-instructions ul {
          margin-top: 5px;
        }
        .download-button {
          display: inline-block;
          padding: 8px 16px;
          background-color: #4CAF50;
          color: white;
          text-decoration: none;
          border-radius: 4px;
          text-align: center;
        }
        .download-button:hover {
          background-color: #388E3C;
        }
        #download-container {
          text-align: center;
        }
      `;
      document.head.appendChild(styleElement);
      
      // Добавляем обработчик события для выбора файла
      const fileInput = document.getElementById('input-file');
      if (fileInput) {
        fileInput.addEventListener('change', handleFileSelection);
      }
    } else {
      instructionsDiv.style.display = 'block';
    }
  }
  
  // Функция для скрытия инструкций
  function hideInstructions() {
    const instructionsDiv = document.getElementById('compile-instructions');
    if (instructionsDiv) {
      instructionsDiv.style.display = 'none';
    }
  }
  
  // Обработчик выбора файла
  function handleFileSelection(event) {
    const fileInput = event.target;
    const currentFileName = FILE_NAMES[currentTab];
    
    if (fileInput.files.length === 0) {
      return;
    }
    
    const selectedFile = fileInput.files[0];
    
    // Проверяем имя файла
    if (selectedFile.name !== currentFileName) {
      showStatusMessage(`Выбран файл ${selectedFile.name}, но для текущей вкладки ожидается ${currentFileName}. Файл будет обработан, но убедитесь, что вы выбрали правильный файл.`, true);
    }
    
    // Читаем содержимое файла
    const reader = new FileReader();
    reader.onload = function(e) {
      const fileContent = e.target.result;
      
      // Сохраняем содержимое файла в глобальную переменную для последующего использования
      window.lastSelectedFileContent = fileContent;
      window.lastSelectedFileName = selectedFile.name;
      
      // Показываем сообщение, что файл загружен и готов к обработке
      showStatusMessage(`Файл ${selectedFile.name} загружен и готов к обработке. Нажмите "Компилировать данные", чтобы обновить блоки.`);
    };
    reader.onerror = function() {
      showStatusMessage('Ошибка при чтении файла', true);
    };
    reader.readAsText(selectedFile);
  }
  
  // Функция для отображения опции использования BAT-файла
  function showBatchFileOption() {
    let batchInfoDiv = document.getElementById('batch-file-option');
    if (!batchInfoDiv) {
      batchInfoDiv = document.createElement('div');
      batchInfoDiv.id = 'batch-file-option';
      batchInfoDiv.className = 'batch-file-option';
      batchInfoDiv.innerHTML = `
        <h3>Использование локального редактирования файлов</h3>
        <p>Для работы с файлами вы можете:</p>
        <ol>
          <li>Скачать и запустить BAT-файл, который создаст необходимую структуру папок</li>
          <li>Поместить файлы Ruby в созданную папку Decompiled</li>
          <li>Экспортировать текущие данные и использовать их для обновления файлов</li>
        </ol>
        <div class="batch-actions">
          <button id="generate-batch-btn" class="batch-btn">Сгенерировать BAT-файл</button>
          <button id="export-data-btn" class="batch-btn">Экспортировать данные</button>
        </div>
      `;
      
      document.querySelector('.container').insertAdjacentElement('afterend', batchInfoDiv);
      
      // Добавляем стили для нового раздела
      const styleElement = document.createElement('style');
      styleElement.textContent = `
        .batch-file-option {
          margin: 20px auto;
          padding: 15px;
          border: 1px solid #ccc;
          border-radius: 5px;
          background-color: #f8f9fa;
          max-width: 800px;
        }
        .batch-actions {
          display: flex;
          gap: 10px;
          margin-top: 15px;
        }
        .batch-btn {
          padding: 8px 16px;
          background-color: #4CAF50;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }
        .batch-btn:hover {
          background-color: #388E3C;
        }
      `;
      document.head.appendChild(styleElement);
      
      // Добавляем обработчики событий
      document.getElementById('generate-batch-btn').addEventListener('click', generateBatchFile);
      document.getElementById('export-data-btn').addEventListener('click', exportCurrentData);
    } else {
      batchInfoDiv.style.display = 'block';
    }
  }
  
  // Функция для скрытия опции использования BAT-файла
  function hideBatchFileOption() {
    const batchInfoDiv = document.getElementById('batch-file-option');
    if (batchInfoDiv) {
      batchInfoDiv.style.display = 'none';
    }
  }
  
  // Функция для генерации BAT-файла
  function generateBatchFile() {
    // Содержимое BAT-файла
    const batchContent = `@echo off
echo ==============================================
echo Создание структуры папок и файлов для RB_Script
echo ==============================================

:: Проверяем и создаем папку Decompiled
if not exist "Decompiled" (
  echo Создаем папку Decompiled...
  mkdir "Decompiled"
) else (
  echo Папка Decompiled уже существует.
)

echo.
echo Папка Decompiled создана/проверена.
echo.
echo Следующие шаги:
echo 1. Скопируйте файлы "201 - Library(Enemy).rb", "197 - JobChange.rb" и "204 - Library(Medal).rb" в папку Decompiled
echo 2. В браузере экспортируйте данные для обновления файлов
echo 3. Используйте экспортированные данные для модификации файлов
echo.
echo Нажмите любую клавишу для завершения...
pause > nul
`;

    // Создаем ссылку для скачивания
    const blob = new Blob([batchContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'setup_rb_script_folders.bat';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    showStatusMessage('BAT-файл успешно сгенерирован и скачан');
  }
  
  // Функция для экспорта текущих данных
  function exportCurrentData() {
    try {
      // Получаем текущие данные из вывода
      const outputContent = document.getElementById('output-content').textContent;
      if (!outputContent.trim()) {
        showStatusMessage('Нет данных для экспорта', true);
        return;
      }
      
      // Определяем имя файла в зависимости от вкладки
      let fileName;
      switch (currentTab) {
        case 'library':
          fileName = 'library_enemy_data.txt';
          break;
        case 'jobchange':
          fileName = 'jobchange_data.txt';
          break;
        case 'medal':
          fileName = 'medal_data.txt';
          break;
        default:
          fileName = 'exported_data.txt';
      }
      
      // Создаем инструкцию по использованию
      const instruction = `# Данные для обновления файла ${FILE_NAMES[currentTab]}
# Скопируйте эти данные и замените соответствующие блоки в файле вручную
# -----------------------------------------------------------------------

`;
      const contentWithInstruction = instruction + outputContent;
      
      // Создаем ссылку для скачивания
      const blob = new Blob([contentWithInstruction], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showStatusMessage('Данные успешно экспортированы');
    } catch (e) {
      console.error('Ошибка при экспорте данных:', e);
      showStatusMessage('Ошибка при экспорте данных: ' + e.message, true);
    }
  }
  
  // Функция для отображения сообщения состояния
  function showStatusMessage(message, isError = false) {
    const statusDiv = document.getElementById('status-message') || document.createElement('div');
    
    if (!document.getElementById('status-message')) {
      statusDiv.id = 'status-message';
      document.querySelector('.controls').appendChild(statusDiv);
    }
    
    statusDiv.textContent = message;
    statusDiv.className = isError ? 'error' : 'success';
    statusDiv.style.display = 'block';
    
    // Очищаем предыдущий таймер, если он есть
    if (statusDiv.timerID) {
      clearTimeout(statusDiv.timerID);
    }
    
    // Автоматически скрыть сообщение через 5 секунд, но только если это не ошибка
    if (!isError) {
      statusDiv.timerID = setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 5000);
    }
  }
  

  
  // Функция для компиляции данных
  function compileData() {
    // Получаем данные из окна вывода
    const outputContent = document.getElementById('output-content').textContent;
    if (!outputContent.trim()) {
      showStatusMessage('Нет данных для обновления файла', true);
      return;
    }
    
    // Проверяем, есть ли содержимое файла в глобальной переменной
    if (window.lastSelectedFileContent) {
      // Используем сохраненное содержимое файла
      updateFileContent(window.lastSelectedFileContent);
    } else {
      // Проверяем, выбран ли файл
      const fileInput = document.getElementById('input-file');
      if (fileInput && fileInput.files.length > 0) {
        // Файл выбран, но содержимое еще не обработано
        const reader = new FileReader();
        reader.onload = function(e) {
          const fileContent = e.target.result;
          window.lastSelectedFileContent = fileContent;
          window.lastSelectedFileName = fileInput.files[0].name;
          updateFileContent(fileContent);
        };
        reader.onerror = function() {
          showStatusMessage('Ошибка при чтении файла', true);
        };
        reader.readAsText(fileInput.files[0]);
      } else {
        // Предлагаем пользователю выбрать файл
        showStatusMessage('Пожалуйста, выберите оригинальный файл для обновления', true);
        
        // Делаем поле выбора файла более заметным
        const fileInputContainer = document.getElementById('file-input-container');
        if (fileInputContainer) {
          fileInputContainer.style.border = '2px solid #f44336';
          fileInputContainer.style.padding = '10px';
          fileInputContainer.style.borderRadius = '4px';
          
          // Убираем выделение через 3 секунды
          setTimeout(() => {
            fileInputContainer.style.border = 'none';
            fileInputContainer.style.padding = '0';
          }, 3000);
        }
      }
    }
  }
  
  // Функция для обновления содержимого файла
  function updateFileContent(fileContent) {
    try {
      // Получаем данные из окна вывода
      const outputContent = document.getElementById('output-content').textContent;
      if (!outputContent.trim()) {
        showStatusMessage('Нет данных для обновления файла', true);
        return;
      }
      
      // Обрабатываем в зависимости от текущей вкладки
      let newContent;
      switch (currentTab) {
        case 'library':
          newContent = updateLibraryFile(fileContent, outputContent);
          break;
        case 'jobchange':
          newContent = updateJobChangeFile(fileContent, outputContent);
          break;
        case 'medal':
          newContent = updateMedalFile(fileContent, outputContent);
          break;
        default:
          showStatusMessage('Неподдерживаемая вкладка для компиляции', true);
          return;
      }
      
      // Проверяем, были ли изменения
      if (!newContent) {
        showStatusMessage('Не найдены блоки для обновления', true);
        return;
      }
      
      // Создаем ссылку для скачивания обновленного файла
      const blob = new Blob([newContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const downloadLink = document.getElementById('download-link');
      const downloadContainer = document.getElementById('download-container');
      
      if (downloadLink && downloadContainer) {
        downloadLink.href = url;
        downloadLink.download = FILE_NAMES[currentTab];
        downloadContainer.style.display = 'block';
        
        showStatusMessage('Файл успешно обновлен. Скачайте его и замените оригинальный файл в папке Decompiled.');
      } else {
        showStatusMessage('Ошибка: не найдена ссылка для скачивания', true);
      }
    } catch (e) {
      console.error('Ошибка при обновлении содержимого файла:', e);
      showStatusMessage(`Ошибка при обновлении файла: ${e.message}`, true);
    }
  }
  
  // Функция для обновления файла Library(Enemy)
  function updateLibraryFile(originalContent, newBlocks) {
    console.log("Обновление файла Library(Enemy)...");
    
    // Проверяем, вызывается ли функция напрямую или из updateFileContent
    const isDirectCall = arguments.length === 0;
    let content, outputContent;
    
    if (isDirectCall) {
      // Прямой вызов из обработчика кнопки "Обновить библиотеку"
      const libraryFile = document.getElementById('library-file').files[0];
      
      if (!libraryFile) {
        console.error("Файл Library не выбран");
        showStatusMessage("Файл Library не выбран", true);
        return null;
      }
      
      // Получаем данные из текстового поля вывода
      outputContent = document.getElementById('output-content').textContent;
      if (!outputContent.trim()) {
        console.error("Нет данных для обновления (пустое поле вывода)");
        showStatusMessage("Нет данных для обновления (пустое поле вывода)", true);
        return null;
      }
      
      console.log("Данные для обновления получены, длина:", outputContent.length);
      console.log("Пример данных:", outputContent.substring(0, 100) + "...");
      
      // Читаем файл
      const reader = new FileReader();
      reader.onload = function(e) {
        const fileContent = e.target.result;
        try {
          processLibraryFile(fileContent, outputContent, true); // true - признак прямого вызова
        } catch (error) {
          console.error("Ошибка при обработке файла:", error);
          showStatusMessage("Ошибка при обработке файла: " + error.message, true);
        }
      };
      
      reader.onerror = function() {
        console.error("Ошибка при чтении файла");
        showStatusMessage("Ошибка при чтении файла", true);
      };
      
      reader.readAsText(libraryFile);
      return; // Выходим из функции, т.к. обработка асинхронная
    } else {
      // Вызов из updateFileContent
      content = originalContent;
      outputContent = newBlocks;
      return processLibraryFile(content, outputContent, false); // false - не прямой вызов
    }
  }
  
  // Функция для обработки файла Library(Enemy)
  function processLibraryFile(content, newBlocks, isDirectCall) {
    try {
      console.log("Начинаю обработку файла...");
      
      // Добавляем информацию о файле
      console.log("Размер файла:", content.length, "символов");
      console.log("Количество строк:", content.split('\n').length);
      
      // Проверяем, есть ли в файле ключевые слова для определения формата
      const hasEndKeyword = content.includes("end");
      const hasCommentMarker = content.includes("# ENEMY_DESCRIPTION");
      
      console.log("Формат файла: " + 
        (hasEndKeyword ? "содержит 'end'" : "не содержит 'end'") + ", " +
        (hasCommentMarker ? "содержит комментарий '# ENEMY_DESCRIPTION'" : "не содержит комментарий")
      );
      
      // Определим формат окончания словаря на основе анализа файла
      let dictEndFormat = "} # ENEMY_DESCRIPTION"; // По умолчанию
      
      if (hasEndKeyword && !hasCommentMarker) {
        dictEndFormat = "}\nend"; // Тип 1: имеет end без комментария
      } else if (hasEndKeyword && hasCommentMarker) {
        // Ищем строку с концом словаря, чтобы понять формат
        const lines = content.split('\n');
        const closingLine = lines.find(line => line.trim() === "}" || line.trim() === "} # ENEMY_DESCRIPTION");
        const nextLine = lines[lines.indexOf(closingLine) + 1] || "";
        
        if (nextLine.trim() === "end") {
          dictEndFormat = "}\nend"; // Тип 2: закрывающая скобка и end на разных строках
        } else {
          dictEndFormat = "} # ENEMY_DESCRIPTION"; // Тип 3: комментарий с # ENEMY_DESCRIPTION
        }
      }
      
      console.log("Определен формат окончания словаря:", dictEndFormat);
      
      // Ищем словарь ENEMY_DESCRIPTION
      // Используем более точный подход - сначала найдем строку с объявлением словаря
      const dictionaryStartLine = content.split('\n').findIndex(line => 
        line.trim().startsWith('ENEMY_DESCRIPTION') && line.includes('=') && line.includes('{')
      );
      
      if (dictionaryStartLine === -1) {
        console.error("Не найдена строка с объявлением словаря ENEMY_DESCRIPTION");
        
        // Попробуем подход с регулярным выражением как резервный
        const dictPattern = /ENEMY_DESCRIPTION\s*=\s*{/;
        const dictMatch = content.match(dictPattern);
        
        if (!dictMatch) {
          console.error("Не найден словарь ENEMY_DESCRIPTION и резервный подход тоже не сработал");
          showStatusMessage("Не найден словарь ENEMY_DESCRIPTION", true);
          return null;
        }
        
        console.log("Резервный подход нашел словарь на позиции:", dictMatch.index);
        return processWithRegex(content, newBlocks, isDirectCall, dictMatch.index);
      }
      
      // Найдем позицию начала словаря в строке
      const lines = content.split('\n');
      const dictionaryLine = lines[dictionaryStartLine];
      console.log("Найдена строка словаря:", dictionaryLine);
      
      // Вычислим смещение начала словаря
      let offset = 0;
      for (let i = 0; i < dictionaryStartLine; i++) {
        offset += lines[i].length + 1; // +1 для учета символа новой строки
      }
      
      const openBraceIndex = dictionaryLine.indexOf('{');
      if (openBraceIndex === -1) {
        console.error("Не найдена открывающая скобка в строке словаря");
        showStatusMessage("Ошибка в формате словаря", true);
        return null;
      }
      
      // Вычисляем общий индекс начала словаря
      const dictStartIndex = offset + openBraceIndex;
      console.log("Индекс начала словаря:", dictStartIndex);
      
      // Теперь ищем конец словаря
      // Сначала попробуем найти строку с закрывающей скобкой и комментарием
      let dictEndLine = -1;
      for (let i = dictionaryStartLine + 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line === "}") {
          dictEndLine = i;
          break;
        }
        if (line === "} # ENEMY_DESCRIPTION" || line.startsWith("} #")) {
          dictEndLine = i;
          break;
        }
      }
      
      if (dictEndLine === -1) {
        console.error("Не найден конец словаря в строках файла");
        
        // Попробуем регулярное выражение
        const alternativePatterns = [
          /}\s*# End of ENEMY_DESCRIPTION/i,
          /}\s*#\s*ENEMY_DESCRIPTION/i,
          /}\s*#end/i,
          /}\s*#\s*end/i,
          /}\s*# dictionary end/i,
          /}\s*#/i,
          /}\s*$/m  // Просто закрывающая скобка в конце строки
        ];
        
        // Ищем первое вхождение любого из этих паттернов после dictStartIndex
        let bestMatch = null;
        let bestPosition = content.length;
        
        for (const pattern of alternativePatterns) {
          // Ограничиваем поиск областью после начала словаря
          const subContent = content.substring(dictStartIndex);
          const match = subContent.match(pattern);
          
          if (match && match.index < bestPosition) {
            bestMatch = match;
            bestPosition = match.index;
          }
        }
        
        if (bestMatch) {
          console.log("Найден конец словаря по паттерну на позиции:", dictStartIndex + bestPosition);
          
          // Вычисляем конец словаря
          const dictEndIndex = dictStartIndex + bestPosition + bestMatch[0].length;
          
          // Извлекаем содержимое словаря
          const dictionaryContent = content.substring(dictStartIndex, dictEndIndex);
          
          return processDictionaryContent(dictStartIndex, dictEndIndex, dictionaryContent, content, newBlocks, isDirectCall);
        }
        
        console.error("Не удалось найти конец словаря ни одним методом");
        showStatusMessage("Не найден конец словаря ENEMY_DESCRIPTION", true);
        return null;
      }
      
      // Вычисляем позицию конца словаря
      let endOffset = 0;
      for (let i = 0; i <= dictEndLine; i++) {
        endOffset += lines[i].length + 1; // +1 для учета символа новой строки
      }
      
      // Учитываем длину закрывающей скобки
      const dictEndIndex = endOffset;
      console.log("Индекс конца словаря:", dictEndIndex);
      
      // Извлекаем содержимое словаря
      const dictionaryContent = content.substring(dictStartIndex, dictEndIndex);
      console.log("Длина содержимого словаря:", dictionaryContent.length, "символов");
      
      // Логируем первые 100 символов содержимого словаря для отладки
      console.log("Начало содержимого словаря:", dictionaryContent.substring(0, 100) + "...");
      
      // Ищем первый блок в словаре
      const firstBlockMatch = dictionaryContent.match(/\s*(\d+)\s*=>/);
      if (firstBlockMatch) {
        console.log("Найден первый блок с ID:", firstBlockMatch[1], "на позиции:", firstBlockMatch.index);
      } else {
        console.warn("Не найден первый блок в словаре");
      }
      
      return processDictionaryContent(dictStartIndex, dictEndIndex, dictionaryContent, content, newBlocks, isDirectCall);
    } catch (e) {
      console.error("Ошибка при обработке файла:", e);
      showStatusMessage("Ошибка при обработке файла: " + e.message, true);
      return null;
    }
  }
  
  // Вспомогательная функция для обработки с использованием регулярных выражений
  function processWithRegex(content, newBlocks, isDirectCall, dictStartPosition) {
    // Ищем конец словаря
    const alternativePatterns = [
      /}\s*# ENEMY_DESCRIPTION/i,
      /}\s*# End of ENEMY_DESCRIPTION/i,
      /}\s*#\s*ENEMY_DESCRIPTION/i,
      /}\s*#end/i,
      /}\s*#\s*end/i,
      /}\s*# dictionary end/i,
      /}\s*#/i,
      /}\s*$/m  // Просто закрывающая скобка в конце строки
    ];
    
    // Ищем первое вхождение любого из этих паттернов после dictStartPosition
    let bestMatch = null;
    let bestPosition = content.length;
    
    for (const pattern of alternativePatterns) {
      // Ограничиваем поиск областью после начала словаря
      const subContent = content.substring(dictStartPosition);
      const match = subContent.match(pattern);
      
      if (match && match.index < bestPosition) {
        bestMatch = match;
        bestPosition = match.index;
      }
    }
    
    if (bestMatch) {
      console.log("Найден конец словаря по паттерну на позиции:", dictStartPosition + bestPosition);
      
      // Вычисляем конец словаря
      const dictEndIndex = dictStartPosition + bestPosition + bestMatch[0].length;
      
      // Извлекаем содержимое словаря
      const dictionaryContent = content.substring(dictStartPosition, dictEndIndex);
      
      return processDictionaryContent(dictStartPosition, dictEndIndex, dictionaryContent, content, newBlocks, isDirectCall);
    }
    
    console.error("Не удалось найти конец словаря ни одним методом");
    showStatusMessage("Не найден конец словаря ENEMY_DESCRIPTION", true);
    return null;
  }
  
  // Выделяем общую логику обработки содержимого словаря
  function processDictionaryContent(dictStartIndex, dictEndIndex, dictionaryContent, content, newBlocks, isDirectCall) {
    // Определяем формат окончания словаря
    let dictEndFormat = "} # ENEMY_DESCRIPTION"; // По умолчанию
    
    // Проверяем наличие ключевых слов для определения формата
    const hasEndKeyword = content.includes("end");
    const hasCommentMarker = content.includes("# ENEMY_DESCRIPTION");
    
    if (hasEndKeyword && !hasCommentMarker) {
      dictEndFormat = "}\nend"; // Тип 1: имеет end без комментария
    } else if (hasEndKeyword && hasCommentMarker) {
      // Найдем конец словаря и посмотрим, что идет дальше
      const endPart = content.substring(dictEndIndex - 20, dictEndIndex + 20);
      console.log("Анализируем окончание словаря:", endPart);
      
      if (endPart.includes("}\nend")) {
        dictEndFormat = "}\nend"; // Тип 2: закрывающая скобка и end на разных строках
      }
    }
    
    console.log("Будем использовать формат окончания словаря:", dictEndFormat);
  
    // Парсим блоки из словаря
    const blocks = parseLibraryBlocks(dictionaryContent);
    
    if (blocks.length === 0) {
      console.error("Не найдены блоки для обновления");
      showStatusMessage("Не найдены блоки для обновления", true);
      return null;
    }
    
    console.log(`Найдено ${blocks.length} блоков в оригинальном файле`);
    
    // Парсим новые блоки из textarea
    const newLines = newBlocks.split('\n');
    const newBlocksMap = {};
    
    let currentId = null;
    let currentBlock = [];
    
    // Обрабатываем новые блоки
    for (const line of newLines) {
      const idMatch = line.match(/^\s*(\d+)\s*=>/);
      
      if (idMatch) {
        // Если ранее был открыт блок, сохраняем его
        if (currentId !== null && currentBlock.length > 0) {
          newBlocksMap[currentId] = currentBlock.join('\n');
          currentBlock = [];
        }
        
        currentId = idMatch[1];
        currentBlock.push(line);
      } else if (currentId !== null) {
        currentBlock.push(line);
      }
    }
    
    // Сохраняем последний блок
    if (currentId !== null && currentBlock.length > 0) {
      newBlocksMap[currentId] = currentBlock.join('\n');
    }
    
    console.log(`Найдено ${Object.keys(newBlocksMap).length} новых блоков для обновления`);
    
    // Выводим найденные блоки для отладки
    for (const id in newBlocksMap) {
      console.log(`Блок ${id}, начало: ${newBlocksMap[id].substring(0, 50)}...`);
    }
    
    // Проверяем, есть ли блоки для обновления
    if (Object.keys(newBlocksMap).length === 0) {
      console.error("Не найдены новые блоки для обновления");
      showStatusMessage("Не найдены новые блоки для обновления", true);
      return null;
    }
    
    // Обновляем блоки в оригинальном файле
    let updatedContent = content.substring(0, dictStartIndex);
    updatedContent += "ENEMY_DESCRIPTION = {";
    
    let updatedCount = 0;
    
    for (const block of blocks) {
      // Проверяем, есть ли обновленный блок
      if (newBlocksMap[block.id]) {
        // Заменяем блок на новый
        updatedContent += "\n" + newBlocksMap[block.id];
        updatedCount++;
        console.log(`Обновлен блок с ID: ${block.id}`);
      } else {
        // Сохраняем оригинальный блок
        updatedContent += "\n" + block.content;
      }
    }
    
    // Добавляем конец словаря и оставшуюся часть файла
    // Используем определенный формат завершения словаря
    let remainingContent = "";
    if (dictEndFormat === "}\nend") {
      // Если формат с end, то нужно заменить всё до "end" включительно
      const endIndex = content.indexOf("end", dictEndIndex) + "end".length;
      remainingContent = content.substring(endIndex);
      updatedContent += "\n  " + dictEndFormat;
    } else {
      // Если формат с комментарием, то просто заменяем старый блок
      remainingContent = content.substring(dictEndIndex);
      updatedContent += "\n" + dictEndFormat;
    }
    
    updatedContent += remainingContent;
    
    console.log(`Обновлено ${updatedCount} блоков`);
    
    // Проверяем, вызван ли метод напрямую или из updateFileContent
    if (isDirectCall) {
      // Прямой вызов из кнопки "Обновить библиотеку"
      // Создаем новый файл с обновленным содержимым
      const blob = new Blob([updatedContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      
      // Создаем ссылку для скачивания
      const a = document.createElement('a');
      a.href = url;
      a.download = 'updated_201_-_Library(Enemy).rb';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log("Файл успешно обновлен и сохранен");
      showStatusMessage("Файл успешно обновлен и сохранен");
    }
    
    // Возвращаем обновленное содержимое для updateFileContent
    return updatedContent;
  }
  
  // Функция для обновления файла JobChange
  function updateJobChangeFile(originalContent, newBlocks, isDirectCall = false) {
    try {
      console.log("Начинаем обновление файла JobChange");
      
      // Парсим новые блоки
      const blocks = parseJobChangeBlocks(newBlocks);
      if (blocks.length === 0) {
        console.log("Блоки не найдены в новом содержимом");
        showStatusMessage('Не найдены блоки для обновления', true);
        return null;
      }
      
      console.log(`Найдено ${blocks.length} блоков для обновления`);
      
      // Разделяем оригинальный контент на части
      const [beforeBlocks, blocksContent] = originalContent.split('JOB_DESC_TEXT = {');
      if (!blocksContent) {
        console.error('Не найдена секция JOB_DESC_TEXT');
        return null;
      }
      
      // Начинаем новое содержимое с правильным форматированием
      let newContent = beforeBlocks + 'JOB_DESC_TEXT = {';
      let updatedCount = 0;
      
      // Обновляем каждый блок
      blocks.forEach((block, index) => {
        const id = block.id;
        let content = block.content;
        
        console.log(`Обрабатываем блок с ID: ${id}`);
        
        // Добавляем перенос строки перед первым блоком
        if (index === 0) {
          newContent += '\n';
        }
        
        // Разбиваем блок на строки и анализируем отступы
        const lines = content.split('\n');
        const processedLines = lines.map((line, lineIndex, array) => {
          const trimmedLine = line.trim();
          
          // Определяем базовый отступ для каждой строки
          if (lineIndex === 0) {
            // Первая строка (с ID) получает 4 пробела
            return '    ' + trimmedLine;
          } else if (trimmedLine === '[[') {
            // Строка с [[ получает 6 пробелов
            return '      ' + trimmedLine;
          } else if (trimmedLine.includes('"')) {
            // Строки с кавычками получают 8 пробелов
            return '        ' + trimmedLine;
          } else if (trimmedLine === '],') {
            // Закрывающая скобка первого массива
            return '      ' + trimmedLine;
          } else if (trimmedLine === '[') {
            // Открывающая скобка второго массива
            return '      ' + trimmedLine;
          } else if (trimmedLine === ']]' || trimmedLine === ']],' || trimmedLine === ']],,' || trimmedLine.startsWith(']]') && trimmedLine.endsWith(',')) {
            // Закрывающие скобки и запятые получают 6 пробелов
            return '      ' + trimmedLine;
          } else {
            // Проверяем, является ли текущая строка частью последовательности "],\n["
            const prevLine = lineIndex > 0 ? array[lineIndex - 1].trim() : '';
            const nextLine = lineIndex < array.length - 1 ? array[lineIndex + 1].trim() : '';
            
            if ((prevLine === '],' && trimmedLine === '[') || 
                (trimmedLine === '],' && nextLine === '[')) {
              return '      ' + trimmedLine;
            }
            
            // Остальные строки сохраняют свои отступы
            return line;
          }
        });
        
        // Собираем блок обратно
        newContent += processedLines.join('\n');
        
        // Добавляем запятую после блока
        if (!processedLines[processedLines.length - 1].trim().endsWith(',')) {
          newContent += ',';
        }
        
        // Добавляем двойной перенос строки между блоками
        if (index < blocks.length - 1) {
          newContent += '\n\n';
        }
        
        updatedCount++;
      });
      
      // Закрываем секцию JOB_DESC_TEXT
      newContent += '\n  }';
      
      console.log(`Обновлено ${updatedCount} блоков`);
      
      // Проверяем, вызван ли метод напрямую
      if (isDirectCall) {
        // Создаем новый файл с обновленным содержимым
        const blob = new Blob([newContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        
        // Создаем ссылку для скачивания
        const a = document.createElement('a');
        a.href = url;
        a.download = 'updated_197_-_JobChange.rb';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        console.log("Файл успешно обновлен и сохранен");
        showStatusMessage("Файл успешно обновлен и сохранен");
      }
      
      return newContent;
    } catch (e) {
      console.error('Ошибка при обновлении JobChange файла:', e);
      showStatusMessage('Ошибка при обновлении JobChange файла', true);
      return null;
    }
  }
  
  // Функция для обновления файла Medal
  function updateMedalFile(originalContent, newBlocks) {
    try {
      // Парсим новые блоки
      const blocks = parseMedalBlocks(newBlocks);
      if (blocks.length === 0) {
        showStatusMessage('Не найдены блоки для обновления', true);
        return null;
      }
      
      let updatedContent = originalContent;
      
      // Обновляем каждый блок
      blocks.forEach(block => {
        const id = block.id;
        const content = block.content;
        
        // Ищем блок с таким ID в оригинальном файле с учетом форматирования
        const regex = new RegExp(`\\s*${id}\\s*=>\\s*\\{[^}]*?\\},`, 's');
        const match = updatedContent.match(regex);
        
        if (match) {
          // Получаем контекст блока и его отступы
          const blockContext = match[0];
          
          // Определяем, с новой ли строки начинался оригинальный блок
          const startsWithNewline = /^\s*\n\s*\d+\s*=>/m.test(blockContext);
          
          // Определяем отступ перед началом блока
          const indentMatch = blockContext.match(/^(\s*)/);
          const indent = indentMatch ? indentMatch[1] : '';
          
          // Обрабатываем новый контент, сохраняя форматирование
          let formattedContent = content;
          
          // Добавляем отступ в начало, если он был
          if (indent && !formattedContent.startsWith(indent)) {
            formattedContent = indent + formattedContent.trimStart();
          }
          
          // Добавляем перенос строки перед блоком, если он был
          if (startsWithNewline && !formattedContent.startsWith('\n')) {
            formattedContent = '\n' + formattedContent;
          }
          
          // Заменяем блок с учетом форматирования
          updatedContent = updatedContent.replace(regex, formattedContent);
        } else {
          // Блок не найден, добавляем новый блок в конец
          // Находим последний блок
          const lastBlockMatch = updatedContent.match(/(\d+)\s*=>\s*\{[^}]*?\},\s*$/s);
          if (lastBlockMatch) {
            const position = lastBlockMatch.index + lastBlockMatch[0].length;
            
            // Определяем, был ли перенос строки перед последним блоком
            const lastBlockStart = updatedContent.lastIndexOf('\n', lastBlockMatch.index);
            const lastBlockPrefix = updatedContent.substring(lastBlockStart + 1, lastBlockMatch.index);
            const indentLevel = lastBlockPrefix.match(/^\s*/)[0];
            
            // Добавляем блок с тем же форматированием, что и последний блок
            const newBlockContent = '\n' + indentLevel + content;
            updatedContent = updatedContent.substring(0, position) + newBlockContent + 
                             updatedContent.substring(position);
          } else {
            // Если не нашли последний блок, добавляем в конец файла
            updatedContent += '\n    ' + content;
          }
        }
      });
      
      return updatedContent;
    } catch (e) {
      console.error('Ошибка при обновлении Medal файла:', e);
      showStatusMessage('Ошибка при обновлении Medal файла', true);
      return null;
    }
  }
  
  // Функция для парсинга блоков Library
  function parseLibraryBlocks(content) {
    console.log("Парсинг блоков Library...");
    const blocks = [];
    
    // Проверяем содержимое
    if (!content || typeof content !== 'string') {
      console.error("Пустое или некорректное содержимое для парсинга");
      return blocks;
    }
    
    // Вывод первых 200 символов для отладки
    console.log("Первые 200 символов содержимого:", content.substring(0, 200) + "...");
    
    // Модифицированный подход к поиску блоков
    // Сначала проверим символ "{" - с него должен начинаться контент
    if (!content.trim().startsWith('{')) {
      console.warn("Содержимое не начинается с открывающей скобки '{', это может вызвать проблемы");
    }
    
    // Сначала разбиваем содержимое на отдельные блоки
    // Блок начинается с числа, за которым следует "=>" и открывающая скобка "[" 
    // и заканчивается закрывающей скобкой "]" с запятой
    
    // Разобьем текст на строки для построчного анализа
    const lines = content.split('\n');
    
    // Ищем все строки, которые содержат ID и начало блока
    const blockStartLines = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      // Ищем паттерн: число => [
      if (line.match(/^\d+\s*=>\s*\[/) || line.match(/^\s*\d+\s*=>\s*\[/)) {
        blockStartLines.push(i);
      }
    }
    
    console.log(`Найдено ${blockStartLines.length} потенциальных начал блоков`);
    
    // Если найдены потенциальные начала блоков, обрабатываем их
    if (blockStartLines.length > 0) {
      // Для каждого начала блока определяем его конец и извлекаем содержимое
      for (let i = 0; i < blockStartLines.length; i++) {
        const startLineIndex = blockStartLines[i];
        // Конец блока - либо следующее начало блока, либо конец содержимого
        const endLineIndex = i < blockStartLines.length - 1 ? blockStartLines[i + 1] : lines.length;
        
        // Извлекаем строки этого блока
        const blockLines = lines.slice(startLineIndex, endLineIndex);
        
        // Получаем ID блока из первой строки
        const firstLine = blockLines[0].trim();
        const idMatch = firstLine.match(/^(\d+)\s*=>/);
        
        if (!idMatch) {
          console.warn(`Не удалось извлечь ID из строки: ${firstLine}`);
          continue;
        }
        
        const id = idMatch[1];
        
        // Собираем блок со всеми оригинальными отступами
        const blockContent = blockLines.join('\n');
        
        // Добавляем блок в результат
        blocks.push({
          id: id,
          content: blockContent
        });
        
        console.log(`Обработан блок с ID: ${id}, длина: ${blockContent.length} символов`);
      }
    } else {
      // Запасной вариант - поиск блоков регулярным выражением
      console.log("Пробуем найти блоки с помощью регулярного выражения...");
      
      // Пытаемся найти все блоки вида "число => [содержимое],"
      const blockPattern = /\s*(\d+)\s*=>\s*\[([\s\S]*?)\],(?=\s*\d+\s*=>|\s*})/g;
      
      let match;
      while ((match = blockPattern.exec(content)) !== null) {
        const id = match[1].trim();
        const blockContent = match[0];
        
        blocks.push({
          id: id,
          content: blockContent
        });
        
        console.log(`Найден блок с ID: ${id} через регулярное выражение, длина: ${blockContent.length} символов`);
      }
      
      // Если и этот метод не нашел блоки, пробуем еще один подход
      if (blocks.length === 0) {
        console.log("Пробуем самый простой подход - поиск строк с ID...");
        
        // Ищем все строки, которые содержат ID и начало блока
        let currentBlock = null;
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          const originalLine = lines[i]; // Строка с оригинальным форматированием
          
          // Проверяем, является ли строка началом блока
          const idMatch = line.match(/^(\d+)\s*=>/);
          
          if (idMatch) {
            // Если у нас уже был блок, добавляем его в результат
            if (currentBlock) {
              blocks.push(currentBlock);
            }
            
            // Создаем новый блок
            const id = idMatch[1];
            currentBlock = {
              id: id,
              content: originalLine
            };
          } else if (currentBlock) {
            // Добавляем строку к текущему блоку
            currentBlock.content += '\n' + originalLine;
            
            // Проверяем, является ли эта строка концом блока
            if (line === "],") {
              blocks.push(currentBlock);
              currentBlock = null;
            }
          }
        }
        
        // Добавляем последний блок, если он есть
        if (currentBlock) {
          blocks.push(currentBlock);
        }
      }
    }
    
    console.log(`Всего найдено блоков: ${blocks.length}`);
    
    // Проверяем первый и последний блок, если они есть
    if (blocks.length > 0) {
      const firstBlock = blocks[0];
      const lastBlock = blocks[blocks.length - 1];
      
      console.log(`Первый блок (ID: ${firstBlock.id}): ${firstBlock.content.substring(0, 50)}...`);
      console.log(`Последний блок (ID: ${lastBlock.id}): ${lastBlock.content.substring(0, 50)}...`);
    }
    
    return blocks;
  }
  
  // Функция для парсинга блоков JobChange
  function parseJobChangeBlocks(content) {
    const blocks = [];
    console.log("Начинаем парсинг блоков JobChange");
    console.log("Содержимое для парсинга:", content.substring(0, 200) + "...");

    // Разбиваем содержимое на строки для построчного анализа
    const lines = content.split('\n');
    let currentBlock = null;
    let blockContent = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Ищем начало нового блока (число и #)
      const blockStart = line.match(/^(\d+)\s*(?:=>)?\s*#/);
      
      if (blockStart) {
        // Если у нас уже есть блок, сохраняем его
        if (currentBlock) {
          // Собираем содержимое блока с правильным форматированием
          currentBlock.content = blockContent.join('\n');
          blocks.push(currentBlock);
          blockContent = [];
        }
        
        // Начинаем новый блок
        currentBlock = {
          id: blockStart[1].trim(),
          content: ''
        };
        blockContent.push(line);
      } else if (currentBlock && line) {
        // Добавляем строку к текущему блоку
        blockContent.push(line);
        
        // Если это конец блока (]],), добавляем его в список
        if (line.match(/\]\],?$/)) {
          currentBlock.content = blockContent.join('\n');
          blocks.push(currentBlock);
          currentBlock = null;
          blockContent = [];
        }
      }
    }

    // Добавляем последний блок, если он есть
    if (currentBlock && blockContent.length > 0) {
      currentBlock.content = blockContent.join('\n');
      blocks.push(currentBlock);
    }

    console.log(`Найдено блоков: ${blocks.length}`);
    if (blocks.length > 0) {
      console.log("Пример первого блока:", blocks[0].content);
    }

    return blocks;
  }
  
  // Функция для парсинга блоков Medal
  function parseMedalBlocks(content) {
    const blocks = [];
    const regex = /\s*(\d+)\s*=>\s*\{([\s\S]*?)\},/g;
    
    let match;
    while ((match = regex.exec(content)) !== null) {
      blocks.push({
        id: match[1].trim(),
        content: match[0]
      });
    }
    
    return blocks;
  }

  // Единая функция изменения длины строки, учитывающая текущую вкладку
  function adjustLength(delta) {
    if (currentTab === "jobchange") {
      maxLineLengthJobChangeVar = Math.max(10, maxLineLengthJobChangeVar + delta);
    } else if (currentMode === "JAP") {
      maxLineLengthJap = Math.max(10, maxLineLengthJap + delta);
    } else {
      maxLineLengthRus = Math.max(10, maxLineLengthRus + delta);
    }

    // Если формат уже исправлен, корректируем перед обновлением
    if (isFormatted) {
      fixFormatting();
    }

    updateOutput(); // Вызываем обновление после исправления
  }

  // Единая функция обновления отображения длины строки
  function updateLengthDisplay() {
    let len;
    if (currentTab === "jobchange") {
      len = maxLineLengthJobChangeVar;
    } else {
      len = currentMode === "JAP" ? maxLineLengthJap : maxLineLengthRus;
    }
    document.getElementById('current-length').textContent = len;
  }

  // Единая функция обновления вывода
  function updateOutput() {
    updateLengthDisplay();
    const inputText = document.getElementById('input-data').value;
    if (!inputText.trim()) {
      document.getElementById('output-content').textContent = '';
      return;
    }
    try {
      let output;
      
      if (currentTab === "library") {
        output = processText(inputText);
      } else if (currentTab === "jobchange") {
        output = processJobChangeText(inputText);
      } else if (currentTab === "medal") {
        output = processMedalText(inputText);
      } else if (currentTab === "skillreplacer") {
        // Для вкладки Skill Replacer не выполняем автоматическую обработку
        return;
      }
      
      document.getElementById('output-content').textContent = output;
    } catch (e) {
      document.getElementById('output-content').textContent = 'Ошибка форматирования';
      console.error("Error in updateOutput:", e);
    }
  }

  // Новая функция для обработки текста медалей
  function processMedalText(text) {
    try {
      const lines = text.split('\n');
      let result = "";
      let currentId = null;
      let currentIconId = null;
      let currentPriority = null;
      let japTitle = null;
      let japDescription = null;
      let rusTitle = null;
      let rusDescription = null;
      let collectingJap = false;
      let collectingRus = false;
      
      // Проходим по всем строкам текста
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Пропускаем пустые строки
        if (!line) continue;
        
        // Проверяем, начинается ли строка с ID медали
        const idMatch = line.match(/^(\d+)\s*=>\s*\{/);
        if (idMatch) {
          // Если у нас уже есть данные о медали, добавляем их в результат
          if (currentId !== null) {
            // В зависимости от выбранного языка, используем соответствующие данные
            const title = currentMode === "JAP" ? japTitle : rusTitle;
            const description = currentMode === "JAP" ? japDescription : rusDescription;
            
            if (title && description) {
              result += formatMedal(currentId, currentIconId, title, description, currentPriority);
            }
          }
          
          // Начинаем сбор данных для новой медали
          currentId = idMatch[1];
          collectingJap = false;
          collectingRus = false;
          japTitle = null;
          japDescription = null;
          rusTitle = null;
          rusDescription = null;
          continue;
        }
        
        // Ищем icon_id
        const iconIdMatch = line.match(/:icon_id\s*=>\s*(\d+)/);
        if (iconIdMatch) {
          currentIconId = iconIdMatch[1];
          continue;
        }
        
        // Ищем priority
        const priorityMatch = line.match(/:priority\s*=>\s*(\d+)/);
        if (priorityMatch) {
          currentPriority = priorityMatch[1];
          continue;
        }
        
        // Проверка на конец блока медали
        if (line === "},") {
          collectingJap = false;
          collectingRus = true; // После закрывающей скобки идет русское название
          continue;
        }
        
        // Если мы не в режиме сбора японского текста, и строка не совпадает с паттернами выше,
        // и мы еще не собрали японский заголовок
        if (!collectingJap && !collectingRus && japTitle === null && 
            !iconIdMatch && !priorityMatch && line !== "},") {
          collectingJap = true;
        }
        
        // Сбор японского текста
        if (collectingJap) {
          if (japTitle === null) {
            japTitle = line;
          } else if (japDescription === null) {
            japDescription = line;
            collectingJap = false;
          }
          continue;
        }
        
        // Сбор русского текста
        if (collectingRus) {
          if (rusTitle === null) {
            rusTitle = line;
          } else if (rusDescription === null) {
            rusDescription = line;
            collectingRus = false;
          }
          continue;
        }
      }
      
      // Добавляем последнюю медаль, если есть данные
      if (currentId !== null) {
        const title = currentMode === "JAP" ? japTitle : rusTitle;
        const description = currentMode === "JAP" ? japDescription : rusDescription;
        
        if (title && description) {
          result += formatMedal(currentId, currentIconId, title, description, currentPriority);
        }
      }
      
      return result;
    } catch (e) {
      console.error("Error in processMedalText:", e);
      return "Error processing medal text: " + e.message;
    }
  }
  
  // Функция форматирования медали
  function formatMedal(id, iconId, title, description, priority) {
    return `    ${id} => {
      :icon_id => ${iconId},
      :title => "${title}",
      :description => "${description}",
      :priority => ${priority},
    },\n`;
  }

  // Function to detect input content that contains wide spaces
  function hasWideSpaces(text) {
    return text.includes('　');
  }

  // Improved split function that preserves wide spaces
  function splitByWideSpaces(text) {
    if (!text) return [];
    
    const segments = [];
    let currentItem = '';
    
    // Handle edge case where text starts with wide space
    if (text.startsWith('　')) {
      text = text.substring(1);
    }
    
    // Process each character
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      
      if (char === '　') {
        // Found a wide space
        if (currentItem.trim()) {
          segments.push(currentItem.trim());
        }
        currentItem = '';
      } else {
        // Regular character
        currentItem += char;
      }
    }
    
    // Add the last item if there is one
    if (currentItem.trim()) {
      segments.push(currentItem.trim());
    }
    
    return segments;
  }

  // Unified format function for equipment and skills
  function formatWithWideSpaces(categoryName, inputLines, maxLineLength) {
    const indent = "			   "; // Standard indentation  
    const result = [];
    
    // Step 1: Extract raw content (removing category prefix)
    let rawContent = "";
    inputLines.forEach((line, index) => {
      // Skip empty lines
      if (!line.trim()) return;
      
      let content = line.trim();
      
      // First line usually contains the category name - remove it
      if (index === 0) {
        // Remove category prefix with multiple colon types
        content = content.replace(new RegExp(`^${categoryName.replace(":", "")}[：:]\\s*`), "");
      }
      
      // Add space between lines for normal processing
      rawContent += (index > 0 && !content.startsWith('　') ? " " : "") + content;
    });
    
    // Step 2: Properly parse items preserving wide spaces
    let items = [];
    
    if (hasWideSpaces(rawContent)) {
      // Wide spaces found - split accordingly
      items = splitByWideSpaces(rawContent);
    } else {
      // Fallback to regular space splitting
      items = rawContent.split(/\s+/).filter(item => item.trim());
    }
    
    // Step 3: Format with line length constraints
    let currentLine = `${categoryName} `;
    let firstItem = true;
    
    items.forEach(item => {
      // Skip empty items
      if (!item || !item.trim()) return;
      
      const itemText = item.trim();
      
      if (firstItem) {
        // First item always goes on the first line
        currentLine += itemText;
        firstItem = false;
      } else if ((currentLine.length + 1 + itemText.length + 1) <= maxLineLength) {
        // Item fits on the current line - add with wide space
        currentLine += `　${itemText}`;
      } else {
        // Start a new line
        result.push(currentLine);
        currentLine = `${indent}${itemText}`;
      }
    });
    
    // Add the final line if not empty
    if (currentLine && currentLine !== `${categoryName} `) {
      result.push(currentLine);
    }
    
    // Special case for empty content
    if (result.length === 0 && categoryName === "Способности:") {
      result.push(`${categoryName} Нет`);
    }
    
    return result;
  }

  // Special function for abilities processing
  function formatAbilitiesSection(inputLines, maxLineLength) {
    const categoryName = "Способности:";
    const indent = "			   ";
    const result = [];
    
    // Process all input lines
    let firstLineProcessed = false;
    let currentLine = categoryName + " ";
    
    for (let i = 0; i < inputLines.length; i++) {
      let line = inputLines[i].trim();
      if (!line) continue;
      
      // Process first line to remove category name
      if (!firstLineProcessed) {
        line = line.replace(/^Способности[：:]\s*/, "");
        firstLineProcessed = true;
      }
      
      // Split this line by wide spaces
      const parts = line.split('　');
      
      for (let j = 0; j < parts.length; j++) {
        let part = parts[j].trim();
        if (!part) continue;
        
        // For first item in the section
        if (currentLine === categoryName + " ") {
          currentLine += part;
        } 
        // If item fits on current line
        else if ((currentLine.length + 1 + part.length + 1) <= maxLineLength) {
          currentLine += "　" + part;
        } 
        // Start a new line if doesn't fit
        else {
          result.push(currentLine);
          currentLine = indent + part;
        }
      }
      
      // Only add space between lines if needed
      if (i < inputLines.length - 1 && !currentLine.endsWith(" ")) {
        currentLine += " ";
      }
    }
    
    // Add final line if it has content
    if (currentLine && currentLine !== categoryName + " ") {
      result.push(currentLine);
    }
    
    // Special case for "none"
    if (result.length === 0) {
      result.push(categoryName + " Нет");
    }
    
    return result;
  }

  // Main processing function for JobChange mode
  function processJobChangeText(text) {
    try {
      // Parse input into blocks
      let lines = text.split('\n');
      let blocks = [];
      let currentBlock = null;
      
      for (let line of lines) {
        if (line.trim().match(/^\d+\s*#/)) {
          if (currentBlock) blocks.push(currentBlock);
          currentBlock = { 
            header: line.trim(), 
            description: [],
            equipment: [],
            skills: [],
            abilities: []
          };
        } else if (currentBlock) {
          // Add line to appropriate section based on content
          const trimmedLine = line.trim();
          if (!trimmedLine) continue;
          
          // Check for categories with both colon types
          if (trimmedLine.match(/^Экипировка[：:]/)) {
            currentBlock.equipment.push(trimmedLine);
          } else if (trimmedLine.match(/^　+/) && currentBlock.equipment.length > 0 && 
                    currentBlock.skills.length === 0 && currentBlock.abilities.length === 0) {
            // Indented continuation of equipment
            currentBlock.equipment.push(trimmedLine);
          } else if (trimmedLine.match(/^Навыки[：:]/)) {
            currentBlock.skills.push(trimmedLine);
          } else if (trimmedLine.match(/^　+/) && currentBlock.skills.length > 0 && 
                    currentBlock.abilities.length === 0) {
            // Indented continuation of skills
            currentBlock.skills.push(trimmedLine);
          } else if (trimmedLine.match(/^Способности[：:]/i) || trimmedLine.match(/^Способность[：:]/i)) {
            currentBlock.abilities.push(trimmedLine);
          } else if (trimmedLine.match(/^　+/) && currentBlock.abilities.length > 0) {
            // Indented continuation of abilities
            currentBlock.abilities.push(trimmedLine);
          } else if (currentBlock.abilities.length > 0) {
            // Non-indented continuation of abilities section
            currentBlock.abilities.push(trimmedLine);
          } else if (currentBlock.skills.length > 0) {
            // Non-indented continuation of skills section
            currentBlock.skills.push(trimmedLine);
          } else if (currentBlock.equipment.length > 0) {
            // Non-indented continuation of equipment section
            currentBlock.equipment.push(trimmedLine);
          } else {
            // This is part of the description
            currentBlock.description.push(trimmedLine);
          }
        }
      }
      
      if (currentBlock) blocks.push(currentBlock);
      
      let result = "";
      blocks.forEach(block => {
        // Skip blocks without matching language characters if needed
        let blockText = block.header + "\n" + 
                       block.description.join("\n") + "\n" +
                       block.equipment.join("\n") + "\n" +
                       block.skills.join("\n") + "\n" +
                       block.abilities.join("\n");
                       
        if (currentMode === "RUS" && !/[А-Яа-яЁё]/.test(blockText)) return;
        if (currentMode === "JAP" && !/[\u3040-\u30FF\u4E00-\u9FBF]/.test(blockText)) return;
        
        // Extract ID and title
        let headerParts = block.header.split('#');
        let id = headerParts[0].trim();
        let title = headerParts.length > 1 ? '# ' + headerParts[1].trim() : '';
        
        // Format description
        let formattedDescription = [];
        if (block.description.length > 0) {
          let descText = block.description.join(' ');
          formattedDescription = wrapText(descText, 
                                          currentTab === "jobchange" ? maxLineLengthJobChangeVar : getCurrentMaxLineLength(), 
                                          currentMode);
        }
        
        // Format all sections
        const maxLen = currentTab === "jobchange" ? maxLineLengthJobChangeVar : getCurrentMaxLineLength();
        let formattedEquipment = formatWithWideSpaces("Экипировка:", block.equipment, maxLen);
        let formattedSkills = formatWithWideSpaces("Навыки:", block.skills, maxLen);
        
        // Special processing for abilities
        let formattedAbilities = formatAbilitiesSection(block.abilities, maxLen);
        
        // Build result with proper indentation
        result += `    ${id} => ${title}\n      [[\n`;
        
        // Description section
        formattedDescription.forEach(line => {
          result += `        "${escapeQuotes(line)}",\n`;
        });
        
        // Section separator
        result += `    ],\n    [\n`;
        
        // Equipment, skills and abilities sections
        formattedEquipment.forEach(line => {
          result += `        "${escapeQuotes(line)}",\n`;
        });
        
        formattedSkills.forEach(line => {
          result += `        "${escapeQuotes(line)}",\n`;
        });
        
        formattedAbilities.forEach(line => {
          result += `        "${escapeQuotes(line)}",\n`;
        });
        
        result += `      ]],\n`;
      });
      
      return result;
    } catch (e) {
      console.error("Error in processJobChangeText:", e);
      return "Error processing text: " + e.message;
    }
  }

  // Corrected function to format abilities while preserving wide spaces
  function formatCategoryWithJapaneseStyle(lines, maxLineLength) {
    try {
      if (!lines || lines.length === 0) return [];
      
      // Determine the category from the first line
      const firstLine = lines[0].trim();
      
      // Check for both types of colons in category headers
      let categoryMatch = firstLine.match(/^(Экипировка|Навыки|Способности|Способность)[：:]/);
      
      if (!categoryMatch) return []; // No category found
      
      let categoryName = categoryMatch[1];
      if (categoryName === "Способность") {
        categoryName = "Способности"; // Normalize to plural form
      }
      
      // Detect if the input already has the category name with either colon style
      const hasDuplicateCategory = firstLine.indexOf(categoryName + ":") === 0 || 
                                 firstLine.indexOf(categoryName + "：") === 0;
      
      // Process based on category type
      if (categoryName === "Экипировка") {
        return formatEquipment(categoryName, lines, maxLineLength, hasDuplicateCategory);
      } 
      else if (categoryName === "Навыки") {
        return formatSkills(categoryName, lines, maxLineLength, hasDuplicateCategory);
      }
      else if (categoryName === "Способности") {
        return formatAbilities(categoryName, lines, maxLineLength, hasDuplicateCategory);
      }
      
      return []; // Fallback
    } catch (e) {
      console.error("Error in formatCategoryWithJapaneseStyle:", e);
      return ["Error processing category: " + e.message];
    }
  }

  // Modified format functions to prevent category duplication
  function formatEquipment(categoryName, lines, maxLineLength, hasDuplicateCategory) {
    const indent = "			   "; // Standard indentation
    let result = [];
    
    // Collect all equipment text
    let fullText = "";
    
    lines.forEach((line, index) => {
      let content = line.trim();
      if (index === 0) {
        // Remove the category prefix from the first line
        content = content.replace(/^(Экипировка[：:])\s*/, "");
      }
      fullText += " " + content;
    });
    
    // Split by wide spaces correctly
    let items = [];
    if (fullText.includes('　')) {
      // Use wide spaces as delimiters
      const parts = fullText.split('　');
      for (let i = 0; i < parts.length; i++) {
        if (parts[i].trim()) {
          items.push(parts[i].trim());
        }
      }
    } else {
      // Fallback to regular spaces
      items = fullText.split(' ').filter(Boolean);
    }
    
    if (items.length === 0) return [];
    
    // Process items
    let currentLine = categoryName + ": " + items[0];
    
    for (let i = 1; i < items.length; i++) {
      // Check if adding this item would exceed the line length
      if ((currentLine.length + 1 + items[i].length + 1) <= maxLineLength) {
        currentLine += "　" + items[i];
      } else {
        result.push(currentLine);
        currentLine = indent + items[i];
      }
    }
    
    // Add the last line
    if (currentLine && currentLine !== (categoryName + ": ")) {
      result.push(currentLine);
    }
    
    return result;
  }

  // Similar updates for formatSkills function
  function formatSkills(categoryName, lines, maxLineLength, hasDuplicateCategory) {
    const indent = "			   "; // Standard indentation
    let result = [];
    
    // Collect all skill text
    let fullText = "";
    
    lines.forEach((line, index) => {
      let content = line.trim();
      if (index === 0) {
        // Remove the category prefix from the first line
        content = content.replace(/^(Навыки[：:])\s*/, "");
      }
      fullText += " " + content;
    });
    
    // Extract skills by preserving the original wide spaces
    let skillItems = [];
    
    // Check if the text contains wide spaces
    if (fullText.includes('　')) {
      // Extract original wide-space separated items
      const segmentsByWideSpace = fullText.split('　');
      
      for (let i = 0; i < segmentsByWideSpace.length; i++) {
        const segment = segmentsByWideSpace[i].trim();
        if (segment) {
          skillItems.push(segment);
        }
      }
    } else {
      // Fallback to space splitting
      skillItems = fullText.split(' ').filter(Boolean);
    }
    
    // Process skill items
    let currentLine = categoryName + ": " + skillItems[0];
    
    for (let i = 1; i < skillItems.length; i++) {
      if ((currentLine.length + 1 + skillItems[i].length + 1) <= maxLineLength) {
        // Add a wide space between skills
        currentLine += "　" + skillItems[i];
      } else {
        result.push(currentLine);
        currentLine = indent + skillItems[i];
      }
    }
    
    // Add the last line
    if (currentLine && currentLine !== (categoryName + ": ")) {
      result.push(currentLine);
    }
    
    return result;
  }

  // Updated formatAbilities function
  function formatAbilities(categoryName, lines, maxLineLength, hasDuplicateCategory) {
    const indent = "			   "; // Standard indentation
    let result = [];
    
    // Collect all ability text
    let fullText = "";
    
    lines.forEach((line, index) => {
      let content = line.trim();
      if (index === 0) {
        // Remove the category prefix from the first line
        content = content.replace(/^(Способности[：:])\s*/, "");
      }
      // Add a space between lines to ensure proper separation
      fullText += (index > 0 ? " " : "") + content;
    });
    
    // Clean up the text
    fullText = fullText.trim();
    
    // Properly split abilities by wide spaces
    let abilities = [];
    if (fullText.includes('　')) {
      // Split by wide spaces first
      const wideSpaceSplit = fullText.split('　');
      
      for (let part of wideSpaceSplit) {
        if (part.trim()) {
          abilities.push(part.trim());
        }
      }
    } else {
      // Look for ability patterns: percentages, effects, etc.
      // Split by logical breaks and patterns
      abilities = fullText.split(/\s+(?=[А-Я])/).filter(a => a.trim().length > 0);
      
      // If no clear separations found, treat as a single ability
      if (abilities.length === 0) {
        abilities = [fullText];
      }
    }
    
    // Remove any empty abilities
    abilities = abilities.filter(ability => ability && ability.trim().length > 0);
    
    // Start with category name
    let currentLine = categoryName + ": ";
    let firstAbility = true;
    
    // Process each ability using the line length limit
    for (let i = 0; i < abilities.length; i++) {
      const ability = abilities[i].trim();
      
      // Skip empty abilities
      if (!ability) continue;
      
      // Check if we can add this ability to the current line
      if (firstAbility) {
        // First ability always goes on the first line
        currentLine += ability;
        firstAbility = false;
      } else if ((currentLine.length + 1 + ability.length) <= maxLineLength) {
        // Add ability with proper separator
        currentLine += "　" + ability;
      } else {
        // Line is full, add it to result and start a new line
        result.push(currentLine);
        currentLine = indent + ability;
      }
    }
    
    // Add the last line if it has content
    if (currentLine && currentLine !== (categoryName + ": ")) {
      result.push(currentLine);
    } else if (abilities.length === 0 && currentLine === (categoryName + ": ")) {
      // If we have no abilities, add "Нет" for "None"
      result.push(categoryName + ": Нет");
    }
    
    return result;
  }

  // Process text one line at a time for better readability
  function wrapText(text, maxLen, lang) {
    try {
      if (lang === "JAP") {
        // Japanese text: break by characters
        let lines = [];
        for (let i = 0; i < text.length; i += maxLen) {
          lines.push(text.substr(i, maxLen));
        }
        return lines;
      } else {
        // Russian text processing
        const words = text.split(' ');
        let lines = [];
        let currentLine = '';
        
        for (let word of words) {
          if ((currentLine.length ? currentLine.length + 1 : 0) + word.length <= maxLen) {
            currentLine += (currentLine ? ' ' : '') + word;
          } else {
            lines.push(currentLine);
            currentLine = word;
          }
        }
        
        if (currentLine) {
          lines.push(currentLine);
        }
        
        return lines;
      }
    } catch (e) {
      console.error("Error in wrapText:", e);
      return [text]; // Return original text as fallback
    }
  }

  // Функция экранирования кавычек в строке
  function escapeQuotes(str) {
    return str.replace(/"/g, '\\"');
  }

  // Обновленная функция обработки для вкладки Library
  function processText(text) {
    let lines = text.split('\n');
    
    // Шаг 1: Собираем информацию о блоках и ID
    let allIDs = new Set();       // Все ID, которые нужно создать
    let primaryIDs = new Set();   // ID, которые указаны первыми в каждом блоке
    let blockContents = {};       // Содержимое для каждого ID
    
    // Первый проход - собираем информацию о блоках
    let currentBlock = null;
    
    for (let line of lines) {
      if (isIDLine(line)) {
        // Сохраняем предыдущий блок, если есть
        if (currentBlock) {
          // Сохраняем содержимое для каждого ID в блоке
          for (const id of currentBlock.idList) {
            if (!blockContents[id]) {
              blockContents[id] = [...currentBlock.content];
            }
          }
        }
        
        // Создаем новый блок
        const idText = line.trim();
        const idList = parseIDList(idText);
        
        if (idList.length > 0) {
          // Первый ID считаем первичным (основным)
          primaryIDs.add(idList[0]);
          
          // Все ID добавляем в общий набор
          for (const id of idList) {
            allIDs.add(id);
          }
        }
        
        currentBlock = { 
          idList: idList,
          content: [] 
        };
      } else {
        if (currentBlock) {
          currentBlock.content.push(line);
        }
      }
    }
    
    // Сохраняем последний блок
    if (currentBlock) {
      for (const id of currentBlock.idList) {
        if (!blockContents[id]) {
          blockContents[id] = [...currentBlock.content];
        }
      }
    }
    
    // Шаг 2: Определяем диапазон первичных ID
    const primaryIDArray = Array.from(primaryIDs);
    
    if (primaryIDArray.length === 0) {
      return ""; // Нет блоков для обработки
    }
    
    const minPrimaryID = Math.min(...primaryIDArray);
    const maxPrimaryID = Math.max(...primaryIDArray);
    
    // Шаг 3: Создаем финальные блоки в правильном порядке
    let finalBlocks = [];
    
    // Сначала добавляем блоки с ID в диапазоне первичных ID
    for (let id = minPrimaryID; id <= maxPrimaryID; id++) {
      if (allIDs.has(id) && blockContents[id]) {
        finalBlocks.push({
          id: id,
          content: blockContents[id]
        });
      }
    }
    
    // Затем добавляем блоки с ID вне диапазона первичных ID
    const externalIDs = Array.from(allIDs)
      .filter(id => id < minPrimaryID || id > maxPrimaryID)
      .sort((a, b) => a - b);
    
    for (const id of externalIDs) {
      if (blockContents[id]) {
        finalBlocks.push({
          id: id,
          content: blockContents[id]
        });
      }
    }
    
    // Шаг 4: Формируем результат
    let result = '';
    
    for (const block of finalBlocks) {
      const processedBlock = { id: block.id.toString(), content: block.content };
      result += processBlock(processedBlock) + '\n';
    }
    
    return result;
  }

  // Функция для проверки строки на ID (включая диапазоны вида "2-3")
  function isIDLine(line) {
    // Проверяем различные форматы ID:
    // - Просто число: "123"
    // - Диапазон: "123-456"
    // - С комментарием: "123 #комментарий" или "123-456 #комментарий"
    // - Список ID через запятую: "146, 559" или "146,559"
    return line.trim().match(/^(\d+(-\d+)?)(,\s*\d+)*(\s*#.*)?$/);
  }

  // Обновленная функция для очистки ID от комментариев
  function cleanIDText(idText) {
    // Удаляем комментарий после #
    return idText.replace(/#.*$/, '').trim();
  }

  // Функция для парсинга списка ID (включая через запятую)
  function parseIDList(idText) {
    // Очищаем от комментариев
    const cleanedText = cleanIDText(idText);
    
    // Разбиваем по запятым и обрабатываем каждую часть
    const parts = cleanedText.split(',').map(part => part.trim());
    
    // Массив для хранения всех ID
    let allIDs = [];
    
    // Обрабатываем каждую часть (может быть отдельным ID или диапазоном)
    for (const part of parts) {
      if (part.includes('-')) {
        // Это диапазон - используем существующую функцию для распаковки
        const rangeIDs = expandIDRange(part);
        allIDs = allIDs.concat(rangeIDs);
      } else if (part) { // Проверяем, что часть не пуста
        // Это отдельный ID
        allIDs.push(parseInt(part));
      }
    }
    
    return allIDs;
  }

  // Обновленная функция для распаковки диапазона ID в массив
  function expandIDRange(idText) {
    // Сначала очищаем ID от комментариев
    const cleanedID = cleanIDText(idText);
    
    if (!cleanedID.includes('-')) {
      return [parseInt(cleanedID)];
    }
    
    const [start, end] = cleanedID.split('-').map(Number);
    const result = [];
    
    for (let id = start; id <= end; id++) {
      result.push(id);
    }
    
    return result;
  }

  // Функция для проверки строки на наличие символов нужного языка
  function isLineInActiveLang(line) {
    if (currentMode === "RUS") {
      return /[А-Яа-яЁё]/.test(line);
    } else if (currentMode === "JAP") {
      return /[\u3040-\u30FF\u4E00-\u9FBF]/.test(line);
    }
    return false;
  }

  // Обрабатывает отдельный блок для Library
  function processBlock(block) {
    let outputLines = [];
    let illustrationLine = "";
    
    function addLine(line) {
      if (line === "") {
        if (outputLines.length === 0 || outputLines[outputLines.length - 1] !== "") {
          outputLines.push("");
        }
      } else {
        outputLines.push(line);
      }
    }
    
    // Сначала ищем информацию об иллюстрации во всем блоке
    let japIllustration = "";
    let rusIllustration = "";
    
    block.content.forEach(line => {
      const trimmedLine = line.trim();
      if (trimmedLine.match(/^Иллюстрация[:：]/)) {
        rusIllustration = trimmedLine;
      } else if (trimmedLine.match(/^イラスト：/)) {
        japIllustration = trimmedLine;
      }
    });
    
    // Добавляем строки активного языка
    block.content.forEach(line => {
      if (line.trim() === "") {
        addLine("");
        return;
      }
      
      // Пропускаем строки с информацией об иллюстрации
      if (line.trim().match(/^Иллюстрация[:：]/) || line.trim().match(/^イラスト：/)) {
        return;
      }
      
      if (isLineInActiveLang(line)) {
        let splitted = splitIntoLines(line, getCurrentMaxLineLength());
        splitted.forEach(subLine => addLine(subLine));
      }
    });
    
    // Выбираем источник информации об иллюстрации
    if (currentMode === "RUS") {
      illustrationLine = rusIllustration || japIllustration;
    } else {
      illustrationLine = japIllustration || rusIllustration;
    }
    
    // Добавляем информацию об иллюстрации с правильным форматированием
    if (illustrationLine) {
      // Извлекаем имя иллюстратора
      let illustratorName = "";
      if (illustrationLine.match(/^Иллюстрация[:：]/)) {
        illustratorName = illustrationLine.replace(/^Иллюстрация[:：]\s*/, "");
      } else if (illustrationLine.match(/^イラスト：/)) {
        illustratorName = illustrationLine.replace(/^イラスト：\s*/, "");
      }
      
      // Форматируем согласно выбранному языку
      addLine("");
      if (currentMode === "JAP") {
        addLine(illustrationPrefixJAP + illustratorName);
      } else {
        addLine(illustrationPrefixRUS + " " + illustratorName);
      }
    }
    
    // Форматируем результат так, как он будет выглядеть в файле
    const blockIdIndent = "    "; // 4 пробела перед ID блока
    const contentIndent = "      "; // 6 пробелов перед содержимым
    
    let result = `${blockIdIndent}${block.id} => [\n`;
    
    // Добавляем содержимое с отступами
    outputLines.forEach(line => {
      result += `${contentIndent}"${escapeQuotes(line)}",\n`;
    });
    
    // Закрываем блок
    result += `${blockIdIndent}],`;
    
    return result;
  }

  // Разбивка текста на строки с учётом максимальной длины для Library
  function splitIntoLines(text, maxLen) {
    if (currentMode === "JAP") {
      let lines = [];
      for (let i = 0; i < text.length; i += maxLen) {
        lines.push(text.substr(i, maxLen));
      }
      return lines;
    } else {
      const words = text.replace(/\n/g, ' ').split(' ').filter(Boolean);
      let lines = [];
      let currentLine = '';
      words.forEach(word => {
        if ((currentLine.length ? currentLine.length + 1 : 0) + word.length > maxLen) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine += (currentLine ? ' ' : '') + word;
        }
      });
      if (currentLine) lines.push(currentLine);
      return lines;
    }
  }

  // Возвращает текущую максимальную длину строки для выбранного языка (для Library)
  function getCurrentMaxLineLength() {
    return currentMode === "JAP" ? maxLineLengthJap : maxLineLengthRus;
  }

  
  // Обновленная функция парсинга файла Skills
  function parseSkills(text) {
    console.log("Начинаем парсинг Skills...");
    const skillMap = {};
    
    // Проверка формата файла
    if (text.indexOf("Skill") === -1) {
      console.warn("Предупреждение: в файле не найдены записи с 'Skill'");
    }
    
    // Пробуем разные регулярные выражения для поиска навыков
    const blocks = text.split(/^Skill\s+/gm);
    console.log(`Найдено блоков: ${blocks.length - 1}`);
    
    blocks.forEach((block, index) => {
      if (index === 0 || !block.trim()) return; // Пропускаем первый блок (он перед первым Skill)
      
      const lines = block.split('\n');
      if (lines.length === 0) return;
      
      // Получаем номер навыка из первой строки
      const firstLine = lines[0].trim();
      const skillNumberMatch = firstLine.match(/^(\d+)/);
      
      if (!skillNumberMatch) {
        console.warn(`Не удалось извлечь номер навыка из строки: ${firstLine}`);
        return;
      }
      
      const skillNumber = skillNumberMatch[1];
      
      // Ищем строку с именем
      const nameLine = lines.find(line => line.trim().match(/^Name\s*=\s*"/i));
      
      if (!nameLine) {
        console.warn(`Не найдена строка с именем для навыка ${skillNumber}`);
        return;
      }
      
      // Извлекаем имя из строки "Name = "имя"..."
      const nameMatch = nameLine.match(/Name\s*=\s*"([^"]+)"/i);
      
      if (nameMatch && nameMatch[1]) {
        const name = nameMatch[1].trim();
        skillMap[skillNumber] = name;
        
        if (index < 5 || index > blocks.length - 5) {
          console.log(`Добавлен навык: ${skillNumber} => ${name}`);
        }
      } else {
        console.warn(`Не удалось извлечь имя из строки: ${nameLine}`);
      }
    });
    
    console.log(`Всего обработано навыков: ${Object.keys(skillMap).length}`);
    return skillMap;
  }

  // Function to replace Skill references in main text with skill names
  function replaceSkills(text, skillMap) {
    // Улучшенное регулярное выражение для поиска паттернов Skill
    return text.replace(/Skill\s+(\d+)/gi, function(match, number) {
      console.log(`Обнаружено совпадение: ${match}, номер: ${number}, замена на: ${skillMap[number] || match}`);
      return skillMap[number] || match;
    });
  }

  // Обновленная функция обработки для Skill Replacer
  function processSkillReplacer() {
    try {
      console.log("Начинаем обработку Skills...");
      const inputData = document.getElementById('input-data');
      const mainText = inputData.value;
      if (!mainText.trim()) {
        alert('Пожалуйста, введите текст с упоминаниями навыков!');
        return;
      }
      
      const skillsFileInput = document.getElementById('skills-file-input');
      if (!skillsFileInput || !skillsFileInput.files[0]) {
        alert('Пожалуйста, загрузите файл Skills!');
        return;
      }
      
      console.log("Файл Skills выбран, читаем содержимое...");
      const reader = new FileReader();
      
      reader.onload = function(e) {
        try {
          console.log("Файл прочитан, размер:", e.target.result.length);
          const skillMap = parseSkills(e.target.result);
          console.log("Карта навыков создана, найдено навыков:", Object.keys(skillMap).length);
          
          const result = replaceSkills(mainText, skillMap);
          console.log("Обработка завершена, обновляем поле ввода...");
          inputData.value = result;
          alert('Обработка успешно завершена!');
        } catch (err) {
          console.error("Ошибка при обработке: ", err);
          alert('Ошибка обработки файла Skills: ' + err.message);
        }
      };
      
      reader.onerror = function() {
        console.error("Ошибка чтения файла");
        alert('Ошибка чтения файла Skills!');
      };
      
      reader.readAsText(skillsFileInput.files[0]);
    } catch (e) {
      console.error("Общая ошибка в processSkillReplacer:", e);
      alert('Ошибка обработки: ' + e.message);
    }
  }
</script>
</body>
</html>
