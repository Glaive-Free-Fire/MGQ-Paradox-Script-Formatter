<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>RB_Script_AutoFormatter</title>
    <style>
        body { margin: 20px; font-family: Arial, sans-serif; }
        .header { text-align: center; margin-bottom: 20px; }
        .lang-controls { text-align: center; margin-bottom: 20px; }
        .lang-btn {
            padding: 5px 10px;
            margin: 0 5px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #f0f0f0;
        }
        .lang-btn.active {
            background: #fff;
            border-bottom: 2px solid #000;
        }
        .container { display: flex; gap: 20px; margin-top: 20px; }
        .editor, .output { flex: 1; }
        textarea { width: 100%; height: 300px; padding: 10px; }
        .output-content { 
            border: 1px solid #ccc; 
            padding: 10px; 
            height: 300px; 
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .controls { 
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .length-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .length-btn {
            padding: 5px 10px;
            min-width: 30px;
        }
        .tabs { 
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
        }
        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .tab-btn.active {
            background: #fff;
            border-bottom: 2px solid #000;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>RB_Script_AutoFormatter</h1>
    </div>

    <!-- Вкладки -->
    <div class="tabs">
        <button class="tab-btn active" data-mode="library">Library(Enemy)</button>
        <button class="tab-btn" data-mode="jobchange">JobChange</button>
    </div>

    <!-- Кнопки выбора языка -->
    <div class="lang-controls">
        <button class="lang-btn active" id="btn-rus">RUS</button>
        <button class="lang-btn" id="btn-jap">JAP</button>
    </div>

    <div class="container">
        <div class="editor">
            <h3>Ввод данных:</h3>
            <textarea id="input-data" placeholder="Введите текст с описанием..."></textarea>
        </div>
        <div class="output">
            <h3>Результат:</h3>
            <div id="output-content" class="output-content"></div>
        </div>
    </div>

    <div class="controls">
        <div class="length-control">
            <span>ДЛИНА СТРОКИ:</span>
            <button class="length-btn" id="decrease-length">-</button>
            <span id="current-length"></span>
            <button class="length-btn" id="increase-length">+</button>
        </div>
        <button id="copy-btn">Копировать результат</button>
        <button id="clear-btn">Исправить</button>
    </div>

<script>
  // Глобальные переменные для всех режимов
  let currentMode = "RUS"; // Текущий язык
  let currentTab = "library"; // Текущая вкладка
  let maxLineLengthRus = 39;
  let maxLineLengthJap = 22;
  let maxLineLengthJobChangeVar = 30; // Лимит строки для JobChange
  let isFormatted = false; // Флаг исправленного форматирования

  // Префиксы для иллюстрации
  const illustrationPrefixRUS = "Иллюстрация:";
  const illustrationPrefixJAP = "イラスト：";

  // Переключение вкладок
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentTab = btn.getAttribute('data-mode');
      isFormatted = false; // Сброс флага исправленного форматирования
      updateOutput();
    });
  });

  // Обработчики кнопок выбора языка
  const btnRus = document.getElementById('btn-rus');
  const btnJap = document.getElementById('btn-jap');
  btnRus.addEventListener('click', () => {
    currentMode = "RUS";
    btnRus.classList.add('active');
    btnJap.classList.remove('active');
    updateOutput();
  });
  btnJap.addEventListener('click', () => {
    currentMode = "JAP";
    btnJap.classList.add('active');
    btnRus.classList.remove('active');
    updateOutput();
  });

  // Обработчик ввода данных
  const inputEl = document.getElementById('input-data');
  inputEl.addEventListener('input', updateOutput);

  // Обработчик кнопок изменения длины строки
  document.getElementById('decrease-length').addEventListener('click', () => adjustLength(-1));
  document.getElementById('increase-length').addEventListener('click', () => adjustLength(1));
  document.getElementById('copy-btn').addEventListener('click', copyToClipboard);
  document.getElementById('clear-btn').addEventListener('click', fixFormatting);

  // Функция копирования в буфер
  function copyToClipboard() {
    navigator.clipboard.writeText(document.getElementById('output-content').textContent)
      .then(() => alert('Текст скопирован!'))
      .catch(err => console.error('Ошибка копирования:', err));
  }

  // Единая функция изменения длины строки, учитывающая текущую вкладку
  function adjustLength(delta) {
    if (currentTab === "jobchange") {
      maxLineLengthJobChangeVar = Math.max(10, maxLineLengthJobChangeVar + delta);
    } else if (currentMode === "JAP") {
      maxLineLengthJap = Math.max(10, maxLineLengthJap + delta);
    } else {
      maxLineLengthRus = Math.max(10, maxLineLengthRus + delta);
    }

    // Если формат уже исправлен, корректируем перед обновлением
    if (isFormatted) {
      fixFormatting();
    }

    updateOutput(); // Вызываем обновление после исправления
  }

  // Единая функция обновления отображения длины строки
  function updateLengthDisplay() {
    let len;
    if (currentTab === "jobchange") {
      len = maxLineLengthJobChangeVar;
    } else {
      len = currentMode === "JAP" ? maxLineLengthJap : maxLineLengthRus;
    }
    document.getElementById('current-length').textContent = len;
  }

  // Единая функция обновления вывода
  function updateOutput() {
    updateLengthDisplay();
    const inputText = document.getElementById('input-data').value;
    if (!inputText.trim()) {
      document.getElementById('output-content').textContent = '';
      return;
    }
    try {
      let output = currentTab === "library" ? processText(inputText) : processJobChangeText(inputText);
      document.getElementById('output-content').textContent = output;
    } catch (e) {
      document.getElementById('output-content').textContent = 'Ошибка форматирования';
      console.error("Error in updateOutput:", e);
    }
  }

  // Функция обработки JobChange с прямым форматированием
  function processJobChangeText(text) {
    try {
      // Parse input into blocks
      let lines = text.split('\n');
      let blocks = [];
      let currentBlock = null;
      
      for (let line of lines) {
        if (line.trim().match(/^\d+\s*#/)) {
          if (currentBlock) blocks.push(currentBlock);
          currentBlock = { 
            header: line.trim(), 
            description: [],
            equipment: [],
            skills: [],
            abilities: []
          };
        } else if (currentBlock) {
          // Add line to appropriate section based on content
          const trimmedLine = line.trim();
          if (!trimmedLine) continue;
          
          // Check for Japanese-style colons (：) as well as regular ones
          if (trimmedLine.match(/^Экипировка[：:]/)) {
            currentBlock.equipment.push(trimmedLine);
          } else if (trimmedLine.match(/^　+/) && currentBlock.equipment.length > 0 && 
                    currentBlock.skills.length === 0 && currentBlock.abilities.length === 0) {
            // Indented continuation of equipment
            currentBlock.equipment.push(trimmedLine);
          } else if (trimmedLine.match(/^Навыки[：:]/)) {
            currentBlock.skills.push(trimmedLine);
          } else if (trimmedLine.match(/^　+/) && currentBlock.skills.length > 0 && 
                    currentBlock.abilities.length === 0) {
            // Indented continuation of skills
            currentBlock.skills.push(trimmedLine);
          } else if (trimmedLine.match(/^Способности[：:]/i) || trimmedLine.match(/^Способность[：:]/i)) {
            currentBlock.abilities.push(trimmedLine);
          } else if (trimmedLine.match(/^　+/) && currentBlock.abilities.length > 0) {
            // Indented continuation of abilities
            currentBlock.abilities.push(trimmedLine);
          } else if (currentBlock.abilities.length > 0) {
            // Non-indented continuation of abilities section
            currentBlock.abilities.push(trimmedLine);
          } else if (currentBlock.skills.length > 0) {
            // Non-indented continuation of skills section
            currentBlock.skills.push(trimmedLine);
          } else if (currentBlock.equipment.length > 0) {
            // Non-indented continuation of equipment section
            currentBlock.equipment.push(trimmedLine);
          } else {
            // This is part of the description
            currentBlock.description.push(trimmedLine);
          }
        }
      }
      
      if (currentBlock) blocks.push(currentBlock);
      
      let result = "";
      blocks.forEach(block => {
        // Skip blocks without Russian characters if in RUS mode
        let blockText = block.header + "\n" + 
                       block.description.join("\n") + "\n" +
                       block.equipment.join("\n") + "\n" +
                       block.skills.join("\n") + "\n" +
                       block.abilities.join("\n");
                       
        if (currentMode === "RUS" && !/[А-Яа-яЁё]/.test(blockText)) return;
        if (currentMode === "JAP" && !/[\u3040-\u30FF\u4E00-\u9FBF]/.test(blockText)) return;
        
        // Extract ID and title
        let headerParts = block.header.split('#');
        let id = headerParts[0].trim();
        let title = headerParts.length > 1 ? '# ' + headerParts[1].trim() : '';
        
        // Format description
        let formattedDescription = [];
        if (block.description.length > 0) {
          let descText = block.description.join(' ');
          formattedDescription = wrapText(descText, maxLineLengthJobChangeVar, currentMode);
        }
        
        // Format equipment, skills and abilities
        let formattedEquipment = formatCategoryWithJapaneseStyle(block.equipment, maxLineLengthJobChangeVar);
        let formattedSkills = formatCategoryWithJapaneseStyle(block.skills, maxLineLengthJobChangeVar);
        let formattedAbilities = formatCategoryWithJapaneseStyle(block.abilities, maxLineLengthJobChangeVar);
        
        // Build result with proper indentation
        result += `    ${id} => ${title}\n      [[\n`;
        
        // Description section
        formattedDescription.forEach(line => {
          result += `        "${escapeQuotes(line)}",\n`;
        });
        
        // Section separator
        result += `    ],\n    [\n`;
        
        // Equipment, skills and abilities sections
        formattedEquipment.forEach(line => {
          result += `        "${escapeQuotes(line)}",\n`;
        });
        
        formattedSkills.forEach(line => {
          result += `        "${escapeQuotes(line)}",\n`;
        });
        
        formattedAbilities.forEach(line => {
          result += `        "${escapeQuotes(line)}",\n`;
        });
        
        result += `      ]],\n`;
      });
      
      return result;
    } catch (e) {
      console.error("Error in processJobChangeText:", e);
      return "Error processing text: " + e.message;
    }
  }

  // Corrected function to format abilities while preserving wide spaces
  function formatCategoryWithJapaneseStyle(lines, maxLineLength) {
    try {
      if (!lines || lines.length === 0) return [];
      
      // Determine the category from the first line
      const firstLine = lines[0].trim();
      
      // Check for both types of colons in category headers
      let categoryMatch = firstLine.match(/^(Экипировка|Навыки|Способности|Способность)[：:]/);
      
      if (!categoryMatch) return []; // No category found
      
      let categoryName = categoryMatch[1];
      if (categoryName === "Способность") {
        categoryName = "Способности"; // Normalize to plural form
      }
      
      // Detect if the input already has the category name with either colon style
      const hasDuplicateCategory = firstLine.indexOf(categoryName + ":") === 0 || 
                                 firstLine.indexOf(categoryName + "：") === 0;
      
      // Process based on category type
      if (categoryName === "Экипировка") {
        return formatEquipment(categoryName, lines, maxLineLength, hasDuplicateCategory);
      } 
      else if (categoryName === "Навыки") {
        return formatSkills(categoryName, lines, maxLineLength, hasDuplicateCategory);
      }
      else if (categoryName === "Способности") {
        return formatAbilities(categoryName, lines, maxLineLength, hasDuplicateCategory);
      }
      
      return []; // Fallback
    } catch (e) {
      console.error("Error in formatCategoryWithJapaneseStyle:", e);
      return ["Error processing category: " + e.message];
    }
  }

  // Modified format functions to prevent category duplication
  function formatEquipment(categoryName, lines, maxLineLength, hasDuplicateCategory) {
    const indent = "			   "; // Standard indentation
    let result = [];
    
    // Collect all equipment text
    let fullText = "";
    
    lines.forEach((line, index) => {
      let content = line.trim();
      if (index === 0) {
        // Remove the category prefix from the first line
        content = content.replace(/^(Экипировка[：:])\s*/, "");
      }
      fullText += " " + content;
    });
    
    // Split by wide spaces correctly
    let items = [];
    if (fullText.includes('　')) {
      // Use wide spaces as delimiters
      const parts = fullText.split('　');
      for (let i = 0; i < parts.length; i++) {
        if (parts[i].trim()) {
          items.push(parts[i].trim());
        }
      }
    } else {
      // Fallback to regular spaces
      items = fullText.split(' ').filter(Boolean);
    }
    
    if (items.length === 0) return [];
    
    // Process items
    let currentLine = categoryName + ": " + items[0];
    
    for (let i = 1; i < items.length; i++) {
      // Check if adding this item would exceed the line length
      if ((currentLine.length + 1 + items[i].length + 1) <= maxLineLength) {
        currentLine += "　" + items[i];
      } else {
        result.push(currentLine);
        currentLine = indent + items[i];
      }
    }
    
    // Add the last line
    if (currentLine && currentLine !== (categoryName + ": ")) {
      result.push(currentLine);
    }
    
    return result;
  }

  // Similar updates for formatSkills function
  function formatSkills(categoryName, lines, maxLineLength, hasDuplicateCategory) {
    const indent = "			   "; // Standard indentation
    let result = [];
    
    // Collect all skill text
    let fullText = "";
    
    lines.forEach((line, index) => {
      let content = line.trim();
      if (index === 0) {
        // Remove the category prefix from the first line
        content = content.replace(/^(Навыки[：:])\s*/, "");
      }
      fullText += " " + content;
    });
    
    // Extract skills by preserving the original wide spaces
    let skillItems = [];
    
    // Check if the text contains wide spaces
    if (fullText.includes('　')) {
      // Extract original wide-space separated items
      const segmentsByWideSpace = fullText.split('　');
      
      for (let i = 0; i < segmentsByWideSpace.length; i++) {
        const segment = segmentsByWideSpace[i].trim();
        if (segment) {
          skillItems.push(segment);
        }
      }
    } else {
      // Fallback to space splitting
      skillItems = fullText.split(' ').filter(Boolean);
    }
    
    // Process skill items
    let currentLine = categoryName + ": " + skillItems[0];
    
    for (let i = 1; i < skillItems.length; i++) {
      if ((currentLine.length + 1 + skillItems[i].length + 1) <= maxLineLength) {
        // Add a wide space between skills
        currentLine += "　" + skillItems[i];
      } else {
        result.push(currentLine);
        currentLine = indent + skillItems[i];
      }
    }
    
    // Add the last line
    if (currentLine && currentLine !== (categoryName + ": ")) {
      result.push(currentLine);
    }
    
    return result;
  }

  // Updated formatAbilities function
  function formatAbilities(categoryName, lines, maxLineLength, hasDuplicateCategory) {
    const indent = "			   "; // Standard indentation
    let result = [];
    
    // Collect all ability text
    let fullText = "";
    
    lines.forEach((line, index) => {
      let content = line.trim();
      if (index === 0) {
        // Remove the category prefix from the first line
        content = content.replace(/^(Способности[：:])\s*/, "");
      }
      // Add a space between lines to ensure proper separation
      fullText += (index > 0 ? " " : "") + content;
    });
    
    // Clean up the text
    fullText = fullText.trim();
    
    // Properly split abilities by wide spaces
    let abilities = [];
    if (fullText.includes('　')) {
      // Split by wide spaces first
      const wideSpaceSplit = fullText.split('　');
      
      for (let part of wideSpaceSplit) {
        if (part.trim()) {
          abilities.push(part.trim());
        }
      }
    } else {
      // Look for ability patterns: percentages, effects, etc.
      // Split by logical breaks and patterns
      abilities = fullText.split(/\s+(?=[А-Я])/).filter(a => a.trim().length > 0);
      
      // If no clear separations found, treat as a single ability
      if (abilities.length === 0) {
        abilities = [fullText];
      }
    }
    
    // Remove any empty abilities
    abilities = abilities.filter(ability => ability && ability.trim().length > 0);
    
    // Start with category name
    let currentLine = categoryName + ": ";
    let firstAbility = true;
    
    // Process each ability using the line length limit
    for (let i = 0; i < abilities.length; i++) {
      const ability = abilities[i].trim();
      
      // Skip empty abilities
      if (!ability) continue;
      
      // Check if we can add this ability to the current line
      if (firstAbility) {
        // First ability always goes on the first line
        currentLine += ability;
        firstAbility = false;
      } else if ((currentLine.length + 1 + ability.length) <= maxLineLength) {
        // Add ability with proper separator
        currentLine += "　" + ability;
      } else {
        // Line is full, add it to result and start a new line
        result.push(currentLine);
        currentLine = indent + ability;
      }
    }
    
    // Add the last line if it has content
    if (currentLine && currentLine !== (categoryName + ": ")) {
      result.push(currentLine);
    } else if (abilities.length === 0 && currentLine === (categoryName + ": ")) {
      // If we have no abilities, add "Нет" for "None"
      result.push(categoryName + ": Нет");
    }
    
    return result;
  }

  // Improved function to format specific categories
  function formatCategory(categoryName, lines, maxLineLength) {
    try {
      if (!lines || lines.length === 0) return [];
      
      const indent = "			   "; // Standard indentation
      let result = [];
      let items = [];
      
      // Extract items from all lines
      lines.forEach(line => {
        let content = line.trim();
        if (content.startsWith(categoryName)) {
          content = content.substring(categoryName.length).trim();
        }
        
        // Split by wide space and add to items
        content.split('　').filter(Boolean).forEach(item => {
          items.push(item);
        });
      });
      
      if (items.length === 0) {
        // If there are no items but we have lines, just add "Нет" for abilities
        if (categoryName === "Способности:" && lines[0].trim() === "Способности: Нет") {
          return ["Способности: Нет"];
        }
        return [];
      }
      
      // Start with category name
      let currentLine = categoryName + " " + items[0];
      let lineIndex = 1;
      
      // Process remaining items
      while (lineIndex < items.length) {
        const item = items[lineIndex];
        
        // Check if adding this item would exceed the line length
        if ((currentLine.length + 1 + item.length + 1) <= maxLineLength) {
          currentLine += "　" + item;
        } else {
          // Current line is full, add it to results
          result.push(currentLine);
          currentLine = indent + item;
        }
        
        lineIndex++;
      }
      
      // Add the last line if not empty
      if (currentLine && currentLine !== (categoryName + " ") && currentLine !== indent) {
        result.push(currentLine);
      }
      
      return result;
    } catch (e) {
      console.error("Error in formatCategory:", e);
      return [categoryName + " Error"];
    }
  }

  // Process text one line at a time for better readability
  function wrapText(text, maxLen, lang) {
    try {
      if (lang === "JAP") {
        // Japanese text: break by characters
        let lines = [];
        for (let i = 0; i < text.length; i += maxLen) {
          lines.push(text.substr(i, maxLen));
        }
        return lines;
      } else {
        // Russian text processing
        const words = text.split(' ');
        let lines = [];
        let currentLine = '';
        
        for (let word of words) {
          if ((currentLine.length ? currentLine.length + 1 : 0) + word.length <= maxLen) {
            currentLine += (currentLine ? ' ' : '') + word;
          } else {
            lines.push(currentLine);
            currentLine = word;
          }
        }
        
        if (currentLine) {
          lines.push(currentLine);
        }
        
        return lines;
      }
    } catch (e) {
      console.error("Error in wrapText:", e);
      return [text]; // Return original text as fallback
    }
  }

  // Функция экранирования кавычек в строке
  function escapeQuotes(str) {
    return str.replace(/"/g, '\\"');
  }

  // Функция обработки для вкладки Library
  function processText(text) {
    let lines = text.split('\n');
    let blocks = [];
    let currentBlock = null;
    for (let line of lines) {
      if (line.trim().match(/^\d+$/)) { // новая метка блока
        if (currentBlock) {
          blocks.push(currentBlock);
        }
        currentBlock = { id: line.trim(), content: [] };
      } else {
        if (currentBlock) {
          currentBlock.content.push(line);
        }
      }
    }
    if (currentBlock) {
      blocks.push(currentBlock);
    }
    return blocks.map(block => processBlock(block)).join('\n');
  }

  // Функция для проверки строки на наличие символов нужного языка
  function isLineInActiveLang(line) {
    if (currentMode === "RUS") {
      return /[А-Яа-яЁё]/.test(line);
    } else if (currentMode === "JAP") {
      return /[\u3040-\u30FF\u4E00-\u9FBF]/.test(line);
    }
    return false;
  }

  // Обрабатывает отдельный блок для Library
  function processBlock(block) {
    let outputLines = [];
    let illustrationLine = "";
    
    function addLine(line) {
      if (line === "") {
        if (outputLines.length === 0 || outputLines[outputLines.length - 1] !== "") {
          outputLines.push("");
        }
      } else {
        outputLines.push(line);
      }
    }
    
    block.content.forEach(line => {
      if (line.trim() === "") {
        addLine("");
        return;
      }
      if (line.trim().match(/^Иллюстрация[:：]/)) {
        illustrationLine = line.trim();
        return;
      }
      if (isLineInActiveLang(line)) {
        let splitted = splitIntoLines(line, getCurrentMaxLineLength());
        splitted.forEach(subLine => addLine(subLine));
      }
    });
    
    if (illustrationLine) {
      illustrationLine = illustrationLine.replace(/^Иллюстрация[:：]\s*/, "");
      if (currentMode === "JAP") {
        illustrationLine = illustrationPrefixJAP + illustrationLine;
      } else {
        illustrationLine = illustrationPrefixRUS + " " + illustrationLine;
      }
      addLine("");
      addLine(illustrationLine);
    }
    
    let formatted = outputLines.map(line => `    "${escapeQuotes(line)}",`).join('\n');
    return `${block.id} => [\n${formatted}\n],`;
  }

  // Разбивка текста на строки с учётом максимальной длины для Library
  function splitIntoLines(text, maxLen) {
    if (currentMode === "JAP") {
      let lines = [];
      for (let i = 0; i < text.length; i += maxLen) {
        lines.push(text.substr(i, maxLen));
      }
      return lines;
    } else {
      const words = text.replace(/\n/g, ' ').split(' ').filter(Boolean);
      let lines = [];
      let currentLine = '';
      words.forEach(word => {
        if ((currentLine.length ? currentLine.length + 1 : 0) + word.length > maxLen) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine += (currentLine ? ' ' : '') + word;
        }
      });
      if (currentLine) lines.push(currentLine);
      return lines;
    }
  }

  // Возвращает текущую максимальную длину строки для выбранного языка (для Library)
  function getCurrentMaxLineLength() {
    return currentMode === "JAP" ? maxLineLengthJap : maxLineLengthRus;
  }

  // Функция форматирования для вывода
  function fixFormatting() {
    try {
      const outputEl = document.getElementById('output-content');
      
      // First, replace the SAVE marker
      let content = outputEl.textContent.replace(/SAVE/g, '    ],\n    [');
      
      // Create a completely new formatted structure
      let blocks = [];
      let currentBlock = null;
      
      // Parse the content line by line
      const lines = content.split('\n');
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Skip empty lines
        if (!line) continue;
        
        // Check if this is a block header
        if (line.match(/^\d+\s*=>\s*#/)) {
          if (currentBlock) {
            blocks.push(currentBlock);
          }
          currentBlock = {
            header: line,
            sections: []
          };
          
          // Initialize first section
          currentBlock.sections.push([]);
        }
        // Check if we're inside a block
        else if (currentBlock) {
          // Handle array markers
          if (line === '[[') {
            // Skip opening markers - we'll add them during formatting
            continue;
          }
          else if (line === ']],') {
            // Close the block - we'll add closing markers during formatting
            blocks.push(currentBlock);
            currentBlock = null;
            continue;
          }
          else if (line === '[') {
            // Start a new section within the block
            currentBlock.sections.push([]);
            continue;
          }
          else if (line === '],') {
            // End the current section - we'll handle this during formatting
            continue;
          }
          // Handle content lines (with or without quotes)
          else {
            // Clean up the content line
            let contentLine = line;
            if (contentLine.startsWith('"') && contentLine.endsWith('",')) {
              contentLine = contentLine.substring(1, contentLine.length - 2);
            }
            
            // Add to the current section
            if (currentBlock.sections.length > 0) {
              currentBlock.sections[currentBlock.sections.length - 1].push(contentLine);
            }
          }
        }
      }
      
      // Don't forget the last block if it exists
      if (currentBlock) {
        blocks.push(currentBlock);
      }
      
      // Now rebuild the content with proper formatting
      let formattedContent = [];
      
      blocks.forEach(block => {
        // Add block header with 4 spaces
        formattedContent.push('    ' + block.header);
        
        // Add double array opening with 6 spaces
        formattedContent.push('      [[');
        
        // Process each section
        block.sections.forEach((section, sectionIndex) => {
          // Add content lines with 8 spaces
          section.forEach(line => {
            formattedContent.push('        "' + line + '",');
          });
          
          // Close section with proper indentation
          if (sectionIndex < block.sections.length - 1) {
            formattedContent.push('    ],');
            formattedContent.push('    [');
          } else {
            formattedContent.push('      ]],');
          }
        });
      });
      
      // Update the output
      outputEl.textContent = formattedContent.join('\n');
      isFormatted = true;
    } catch (e) {
      console.error("Error in fixFormatting:", e);
      alert("Error in fixFormatting: " + e.message);
    }
  }

  // Инициализация
  document.addEventListener('DOMContentLoaded', function() {
    updateOutput();
  });
</script>
</body>
</html>
