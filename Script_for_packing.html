<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>RB_Script_AutoFormatter</title>
    <style>
        body { margin: 20px; font-family: Arial, sans-serif; }
        .header { text-align: center; margin-bottom: 20px; }
        .lang-controls { text-align: center; margin-bottom: 20px; }
        .lang-btn {
            padding: 5px 10px;
            margin: 0 5px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #f0f0f0;
        }
        .lang-btn.active {
            background: #fff;
            border-bottom: 2px solid #000;
        }
        .container { display: flex; gap: 20px; margin-top: 20px; }
        .editor, .output { flex: 1; }
        textarea { width: 100%; height: 300px; padding: 10px; }
        .output-content { 
            border: 1px solid #ccc; 
            padding: 10px; 
            height: 300px; 
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .controls { 
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .length-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .length-btn {
            padding: 5px 10px;
            min-width: 30px;
        }
		.tabs { 
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
        }
        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .tab-btn.active {
            background: #fff;
            border-bottom: 2px solid #000;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>RB_Script_AutoFormatter</h1>
    </div>

    <!-- Вкладки -->
    <div class="tabs">
        <button class="tab-btn active" data-mode="library">Library(Enemy)</button>
        <button class="tab-btn" data-mode="jobchange">JobChange</button>
    </div>

    <!-- Кнопки выбора языка -->
    <div class="lang-controls">
        <button class="lang-btn active" id="btn-rus">RUS</button>
        <button class="lang-btn" id="btn-jap">JAP</button>
    </div>

    <div class="container">
        <div class="editor">
            <h3>Ввод данных:</h3>
            <textarea id="input-data" placeholder="Введите текст с описанием..."></textarea>
        </div>
        <div class="output">
            <h3>Результат:</h3>
            <div id="output-content" class="output-content"></div>
        </div>
    </div>

    <div class="controls">
        <div class="length-control">
            <span>ДЛИНА СТРОКИ:</span>
            <button class="length-btn" id="decrease-length">-</button>
            <span id="current-length"></span>
            <button class="length-btn" id="increase-length">+</button>
        </div>
        <button id="copy-btn">Копировать результат</button>
		<button id="clear-btn">Исправить</button>

    </div>

<script>
  // Глобальные переменные для всех режимов
  let currentMode = "RUS"; // Текущий язык
  let currentTab = "library"; // Текущая вкладка
  let maxLineLengthRus = 39;
  let maxLineLengthJap = 22;
  let maxLineLengthJobChangeVar = 30; // Лимит строки для JobChange
  let isFormatted = false; // Флаг исправленного форматирования

  // Префиксы для иллюстрации
  const illustrationPrefixRUS = "Иллюстрация:";
  const illustrationPrefixJAP = "イラスト：";

  // Переключение вкладок
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentTab = btn.getAttribute('data-mode');
      isFormatted = false; // Сброс флага исправленного форматирования
      updateOutput();
    });
  });

  // Обработчики кнопок выбора языка
  const btnRus = document.getElementById('btn-rus');
  const btnJap = document.getElementById('btn-jap');
  btnRus.addEventListener('click', () => {
    currentMode = "RUS";
    btnRus.classList.add('active');
    btnJap.classList.remove('active');
    updateOutput();
  });
  btnJap.addEventListener('click', () => {
    currentMode = "JAP";
    btnJap.classList.add('active');
    btnRus.classList.remove('active');
    updateOutput();
  });

  // Обработчик ввода данных
  const inputEl = document.getElementById('input-data');
  inputEl.addEventListener('input', updateOutput);

  // Обработчик кнопок изменения длины строки (единая версия для всех режимов)
  document.getElementById('decrease-length').addEventListener('click', () => adjustLength(-1));
  document.getElementById('increase-length').addEventListener('click', () => adjustLength(1));
  document.getElementById('copy-btn').addEventListener('click', () => {
    navigator.clipboard.writeText(document.getElementById('output-content').textContent)
      .then(() => alert('Текст скопирован!'))
      .catch(err => console.error('Ошибка копирования:', err));
  });
  document.getElementById('clear-btn').addEventListener('click', cleanOutput);

  // Единая функция изменения длины строки, учитывающая текущую вкладку
  function adjustLength(delta) {
    if (currentTab === "jobchange") {
      maxLineLengthJobChangeVar = Math.max(10, maxLineLengthJobChangeVar + delta);
    } else if (currentMode === "JAP") {
      maxLineLengthJap = Math.max(10, maxLineLengthJap + delta);
    } else {
      maxLineLengthRus = Math.max(10, maxLineLengthRus + delta);
    }

  // Если формат уже исправлен, корректируем перед обновлением
    if (isFormatted) {
      fixFormatting();
    }

    updateOutput(); // Вызываем обновление после исправления
  }


  // Единая функция обновления отображения длины строки
  function updateLengthDisplay() {
    let len;
    if (currentTab === "jobchange") {
      len = maxLineLengthJobChangeVar;
    } else {
      len = currentMode === "JAP" ? maxLineLengthJap : maxLineLengthRus;
    }
    document.getElementById('current-length').textContent = len;
  }

  // Единая функция обновления вывода
  // Функция обновления вывода
  function updateOutput() {
    updateLengthDisplay();
    const inputText = document.getElementById('input-data').value;
    if (!inputText.trim()) {
      document.getElementById('output-content').textContent = '';
      return;
    }
    try {
      let output = currentTab === "library" ? processText(inputText) : processJobChangeText(inputText);
      document.getElementById('output-content').textContent = output;
    } catch (e) {
      document.getElementById('output-content').textContent = 'Ошибка форматирования';
    }
  }

// Функция обработки JobChange
  function processJobChangeText(text) {
    let lines = text.split('\n');
    let blocks = [];
    let currentBlock = null;
    
    for (let line of lines) {
      if (line.trim().match(/^\d+\s*#/)) {
        if (currentBlock) blocks.push(currentBlock);
        currentBlock = { header: line.trim(), content: [] };
      } else if (currentBlock) {
        currentBlock.content.push(line);
      }
    }
    if (currentBlock) blocks.push(currentBlock);

    let result = "";
    blocks.forEach(block => {
      let blockText = block.header + "\n" + block.content.join("\n");
      if (!/[А-Яа-яЁё]/.test(blockText)) return;

      let headerParts = block.header.split('#');
      let id = headerParts[0].trim();
      let title = headerParts.length > 1 ? '# ' + headerParts[1].trim() : '';

      let paragraphs = block.content.join('\n').split(/\n\s*\n/).map(p => p.trim()).filter(p => p.length > 0);
      paragraphs = paragraphs.filter(p => /[А-Яа-яЁё]/.test(p));

      let processedParagraphs = paragraphs.map(paragraph =>
        wrapText(paragraph, maxLineLengthJobChangeVar, currentMode)
      );

      if (processedParagraphs.length === 0) return;

      result += `${id} => ${title}\n  `;
      if (!isFormatted) result += "[[\n";

      result += processedParagraphs.map(paraLines => {
        let inner = paraLines.map(line => `    "${escapeQuotes(line)}",`).join("\n");
        return inner ? "  [\n" + inner + "\n  ]," : "";
      }).join("\n");

      if (!isFormatted) result += "\n  ]],\n";
    });

    result = result.replace(/\\?"Слепоту\\?"/g, "«Слепоту»");
    return result;
  }

// Функция wrapText (перенос строк)
  function wrapText(text, maxLen, lang) {
      if (lang === "JAP") {
          // Японский текст: разбивка просто по символам
          let lines = [];
          for (let i = 0; i < text.length; i += maxLen) {
              lines.push(text.substr(i, maxLen));
          }
          return lines;
      } else if (lang === "RUS") {
          // Русский текст: обработка с учетом целостности данных
          
          // Определяем категории для отступов
          const categories = ["Экипировка:", "Навыки:", "Способности:"];
          
          // Разделяем текст по строкам для отдельной обработки категорий
          let paragraphs = text.split(/\n+/);
          let lines = [];
          let currentCategory = ""; // Текущая обрабатываемая категория
          
          for (let paragraph of paragraphs) {
              // Проверяем, является ли абзац началом списка экипировки/навыков/способностей
              let categoryMatch = false;
              
              for (let category of categories) {
                  if (paragraph.startsWith(category)) {
                      categoryMatch = true;
                      currentCategory = category;
                      break;
                  }
              }
              
              // Если это новая категория или продолжение предыдущей
              if (categoryMatch || (currentCategory && paragraph.trim().startsWith('　'))) {
                  let itemsText;
                  let indent = "			   "; // Отступ для продолжения списка
                  
                  if (categoryMatch) {
                      // Обрабатываем строку с категорией особым образом
                      itemsText = paragraph.substring(currentCategory.length).trim();
                  } else {
                      // Это продолжение предыдущей категории
                      itemsText = paragraph.trim();
                      // Если уже есть отступ в начале, сохраняем его
                      if (!paragraph.startsWith(indent)) {
                          categoryMatch = false; // Это значит, что мы не начинаем с категории
                      }
                  }
                  
                  let items = itemsText.split('　').filter(Boolean);
                  let currentLine = categoryMatch ? currentCategory : indent;
                  
                  // Добавляем элементы с учетом длины строки
                  for (let item of items) {
                      if (currentLine.length + 1 + item.length + 1 <= maxLen) {
                          currentLine += (currentLine === indent || currentLine.endsWith('　') ? "" : " ") + item + "　";
                      } else {
                          // Убираем последний пробел и широкий пробел, если они есть
                          if (currentLine.endsWith('　')) {
                              currentLine = currentLine.slice(0, -1);
                          }
                          if (currentLine.endsWith(' ')) {
                              currentLine = currentLine.slice(0, -1);
                          }
                          
                          lines.push(currentLine);
                          currentLine = indent + item + "　";
                      }
                  }
                  
                  // Добавляем последнюю строку, убирая лишние пробелы в конце
                  if (currentLine.endsWith('　')) {
                      currentLine = currentLine.slice(0, -1);
                  }
                  if (currentLine.endsWith(' ')) {
                      currentLine = currentLine.slice(0, -1);
                  }
                  
                  if (currentLine.trim()) {
                      lines.push(currentLine);
                  }
              } else {
                  // Обычный текст - обрабатываем по словам
                  let words = paragraph.split(' ');
                  let currentLine = '';
                  
                  for (let word of words) {
                      if ((currentLine.length ? currentLine.length + 1 : 0) + word.length <= maxLen) {
                          currentLine += (currentLine ? ' ' : '') + word;
                      } else {
                          lines.push(currentLine);
                          currentLine = word;
                      }
                  }
                  
                  if (currentLine) {
                      lines.push(currentLine);
                  }
                  
                  // Сбрасываем текущую категорию после обычного текста
                  currentCategory = "";
              }
          }
          
          return lines;
      }
  }

    

  // Функция экранирования кавычек в строке
  function escapeQuotes(str) {
    return str.replace(/"/g, '\\"');
  }

  // Функция обработки для вкладки Library (без изменений)
  function processText(text) {
    let lines = text.split('\n');
    let blocks = [];
    let currentBlock = null;
    for (let line of lines) {
      if (line.trim().match(/^\d+$/)) { // новая метка блока
        if (currentBlock) {
          blocks.push(currentBlock);
        }
        currentBlock = { id: line.trim(), content: [] };
      } else {
        if (currentBlock) {
          currentBlock.content.push(line);
        }
      }
    }
    if (currentBlock) {
      blocks.push(currentBlock);
    }
    return blocks.map(block => processBlock(block)).join('\n');
  }

  // Функция для проверки строки на наличие символов нужного языка
  function isLineInActiveLang(line) {
    if (currentMode === "RUS") {
      return /[А-Яа-яЁё]/.test(line);
    } else if (currentMode === "JAP") {
      return /[\u3040-\u30FF\u4E00-\u9FBF]/.test(line);
    }
    return false;
  }

  // Обрабатывает отдельный блок для Library
  function processBlock(block) {
    let outputLines = [];
    let illustrationLine = "";
    
    function addLine(line) {
      if (line === "") {
        if (outputLines.length === 0 || outputLines[outputLines.length - 1] !== "") {
          outputLines.push("");
        }
      } else {
        outputLines.push(line);
      }
    }
    
    block.content.forEach(line => {
      if (line.trim() === "") {
        addLine("");
        return;
      }
      if (line.trim().match(/^Иллюстрация[:：]/)) {
        illustrationLine = line.trim();
        return;
      }
      if (isLineInActiveLang(line)) {
        let splitted = splitIntoLines(line, getCurrentMaxLineLength());
        splitted.forEach(subLine => addLine(subLine));
      }
    });
    
    if (illustrationLine) {
      illustrationLine = illustrationLine.replace(/^Иллюстрация[:：]\s*/, "");
      if (currentMode === "JAP") {
        illustrationLine = illustrationPrefixJAP + illustrationLine;
      } else {
        illustrationLine = illustrationPrefixRUS + " " + illustrationLine;
      }
      addLine("");
      addLine(illustrationLine);
    }
    
    let formatted = outputLines.map(line => '  "' + escapeQuotes(line) + '",').join('\n');
    return `${block.id} => [\n${formatted}\n],`;
  }

  // Разбивка текста на строки с учётом максимальной длины для Library
  function splitIntoLines(text, maxLen) {
    if (currentMode === "JAP") {
      let lines = [];
      for (let i = 0; i < text.length; i += maxLen) {
        lines.push(text.substr(i, maxLen));
      }
      return lines;
    } else {
      const words = text.replace(/\n/g, ' ').split(' ').filter(Boolean);
      let lines = [];
      let currentLine = '';
      words.forEach(word => {
        if ((currentLine.length ? currentLine.length + 1 : 0) + word.length > maxLen) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine += (currentLine ? ' ' : '') + word;
        }
      });
      if (currentLine) lines.push(currentLine);
      return lines;
    }
  }

  // Возвращает текущую максимальную длину строки для выбранного языка (для Library)
  function getCurrentMaxLineLength() {
    return currentMode === "JAP" ? maxLineLengthJap : maxLineLengthRus;
  }

  function fixFormatting() {
    const outputEl = document.getElementById('output-content');
    let lines = outputEl.textContent.split('\n');
    let fixedLines = [];
    let insideBlock = false;
    let insideDescription = true;
    let indent = "  ";

    for (let i = 0; i < lines.length; i++) {
      let line = lines[i].trim();

      if (line === "") continue;

      // Начало блока (ID => # Название)
      if (line.match(/^\d+\s*=>\s*#/)) {
        insideBlock = true;
        insideDescription = true;
        fixedLines.push(line);
        fixedLines.push(indent + "[["); // Начало блока
        continue;
      }

      // Удаляем лишние скобки (но сохраняем нужные в середине блока)
      if (line === "[") continue;
      if (line === "],") {
        if (insideDescription) {
          insideDescription = false;
        } else {
          continue;
        }
      }

      fixedLines.push(indent + line);
    }

    if (insideBlock) {
      fixedLines.push(indent + "]],");
    }

    outputEl.textContent = fixedLines.join('\n');
    isFormatted = true;
  }




  // Изменение длины строки (и сохранение формата)
  function adjustLength(delta) {
    if (currentTab === "jobchange") {
      maxLineLengthJobChangeVar = Math.max(10, maxLineLengthJobChangeVar + delta);
    } else if (currentMode === "JAP") {
      maxLineLengthJap = Math.max(10, maxLineLengthJap + delta);
    } else {
      maxLineLengthRus = Math.max(10, maxLineLengthRus + delta);
    }

    // Если формат уже исправлен, переформатируем с учётом исправлений
    if (isFormatted) fixFormatting();
    updateOutput();
  }

  // Обработчики кнопок
  document.getElementById('decrease-length').addEventListener('click', () => adjustLength(-1));
  document.getElementById('increase-length').addEventListener('click', () => adjustLength(1));
  document.getElementById('copy-btn').addEventListener('click', () => {
    navigator.clipboard.writeText(document.getElementById('output-content').textContent)
      .then(() => alert('Текст скопирован!'))
      .catch(err => console.error('Ошибка копирования:', err));
  });
  document.getElementById('clear-btn').addEventListener('click', cleanOutput);
  document.getElementById('fix-btn').addEventListener('click', fixFormatting);

  // Инициализация
  updateOutput();

// --- Упрощённая функция очистки вывода ---
  function cleanOutput() {
      const outputEl = document.getElementById('output-content');
      let lines = outputEl.textContent.split('\n');
      let newLines = [];
      let inBlock = false;
      let prevLine = '';
      
      // Track categories and indentation states
      const categories = ["Экипировка:", "Навыки:", "Способности:"];
      let currentCategory = "";
      const indent = "			   "; // Standard indentation for continuation lines
      
      for(let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const trimmedLine = line.trim();
          
          // Check if we're at the start or end of a block
          if(trimmedLine === '[[') {
              newLines.push(line);
              inBlock = true;
              i++; // Skip the next line after [[
              continue;
          }
          
          if(trimmedLine === ']],') {
              if(prevLine.trim() === '],') {
                  newLines.pop(); // Remove the second-to-last line before ]],
              }
              newLines.push(line);
              inBlock = false;
              currentCategory = "";
              continue;
          }
          
          if(inBlock) prevLine = line;
          
          // Check if line contains a category
          let isCategoryLine = false;
          for(let category of categories) {
              if(trimmedLine.startsWith(category)) {
                  currentCategory = category;
                  isCategoryLine = true;
                  break;
              }
          }
          
          // Process the line based on content type
          if(isCategoryLine) {
              // This is a category header line - clean it but keep as is
              let cleanedLine = trimmedLine.replace(/\s*　\s*/g, '　');
              newLines.push(cleanedLine);
              
          } else if(currentCategory && !isCategoryLine) {
              // This is a continuation of a category - apply indentation
              
              // If line starts with wide space or has indentation already
              let content = trimmedLine;
              if(content.startsWith('　')) {
                  content = content.substring(1);
              }
              
              // Clean spaces around wide spaces
              content = content.replace(/\s*　\s*/g, '　');
              
              // Apply proper indentation
              newLines.push(indent + content);
              
          } else {
              // Regular line - just clean it
              let cleanedLine = trimmedLine.replace(/\s*　\s*/g, '　');
              newLines.push(cleanedLine);
          }
      }
      
      outputEl.textContent = newLines.join('\n');
      isFormatted = true;
  }
</script>
</body>
</html>
