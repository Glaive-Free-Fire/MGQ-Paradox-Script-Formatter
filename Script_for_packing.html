<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>RB_Script_AutoFormatter</title>
    <style>
        body { margin: 20px; font-family: Arial, sans-serif; }
        .header { text-align: center; margin-bottom: 20px; }
        .lang-controls { text-align: center; margin-bottom: 20px; }
        .lang-btn {
            padding: 5px 10px;
            margin: 0 5px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #f0f0f0;
        }
        .lang-btn.active {
            background: #fff;
            border-bottom: 2px solid #000;
        }
        .container { display: flex; gap: 20px; margin-top: 20px; }
        .editor, .output { flex: 1; }
        textarea { width: 100%; height: 300px; padding: 10px; }
        .output-content { 
            border: 1px solid #ccc; 
            padding: 10px; 
            height: 300px; 
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .controls { 
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .length-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .length-btn {
            padding: 5px 10px;
            min-width: 30px;
        }
		.tabs { 
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
        }
        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .tab-btn.active {
            background: #fff;
            border-bottom: 2px solid #000;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>RB_Script_AutoFormatter</h1>
    </div>

    <!-- Вкладки -->
    <div class="tabs">
        <button class="tab-btn active" data-mode="library">Library(Enemy)</button>
        <button class="tab-btn" data-mode="jobchange">JobChange</button>
    </div>

    <!-- Кнопки выбора языка -->
    <div class="lang-controls">
        <button class="lang-btn active" id="btn-rus">RUS</button>
        <button class="lang-btn" id="btn-jap">JAP</button>
    </div>

    <div class="container">
        <div class="editor">
            <h3>Ввод данных:</h3>
            <textarea id="input-data" placeholder="Введите текст с описанием..."></textarea>
        </div>
        <div class="output">
            <h3>Результат:</h3>
            <div id="output-content" class="output-content"></div>
        </div>
    </div>

    <div class="controls">
        <div class="length-control">
            <span>ДЛИНА СТРОКИ:</span>
            <button class="length-btn" id="decrease-length">-</button>
            <span id="current-length"></span>
            <button class="length-btn" id="increase-length">+</button>
        </div>
        <button id="copy-btn">Копировать результат</button>
        <button id="clear-btn">Исправить</button>
        <button id="report-btn">Репорт</button>


    </div>

<script>
  // Глобальные переменные для всех режимов
  let currentMode = "RUS"; // Текущий язык
  let currentTab = "library"; // Текущая вкладка
  let maxLineLengthRus = 39;
  let maxLineLengthJap = 22;
  let maxLineLengthJobChangeVar = 30; // Лимит строки для JobChange
  let isFormatted = false; // Флаг исправленного форматирования

  // Префиксы для иллюстрации
  const illustrationPrefixRUS = "Иллюстрация:";
  const illustrationPrefixJAP = "イラスト：";

  // Переключение вкладок
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentTab = btn.getAttribute('data-mode');
      isFormatted = false; // Сброс флага исправленного форматирования
      updateOutput();
    });
  });

  // Обработчики кнопок выбора языка
  const btnRus = document.getElementById('btn-rus');
  const btnJap = document.getElementById('btn-jap');
  btnRus.addEventListener('click', () => {
    currentMode = "RUS";
    btnRus.classList.add('active');
    btnJap.classList.remove('active');
    updateOutput();
  });
  btnJap.addEventListener('click', () => {
    currentMode = "JAP";
    btnJap.classList.add('active');
    btnRus.classList.remove('active');
    updateOutput();
  });

  // Обработчик ввода данных
  const inputEl = document.getElementById('input-data');
  inputEl.addEventListener('input', updateOutput);

  // Обработчик кнопок изменения длины строки (единая версия для всех режимов)
  document.getElementById('decrease-length').addEventListener('click', () => adjustLength(-1));
  document.getElementById('increase-length').addEventListener('click', () => adjustLength(1));
  document.getElementById('copy-btn').addEventListener('click', () => {
    navigator.clipboard.writeText(document.getElementById('output-content').textContent)
      .then(() => alert('Текст скопирован!'))
      .catch(err => console.error('Ошибка копирования:', err));
  });
  document.getElementById('clear-btn').addEventListener('click', fixFormatting);

// Глобальный массив для хранения логов ошибок
let errorLogs = [];

// Функция для форматирования текущей даты и времени
function getCurrentTimestamp() {
  const now = new Date();
  return now.toLocaleString();
}

// Функция для записи ошибки в лог
function logError(message, source, lineno, colno, error) {
  const timestamp = getCurrentTimestamp();
  const errorMessage = `[${timestamp}] Error: ${message} at ${source}:${lineno}:${colno}\n`;
  const errorStack = error && error.stack ? error.stack + "\n" : "";
  errorLogs.push(errorMessage + errorStack);
  console.error(errorMessage, error);
}

// Глобальный обработчик ошибок
window.onerror = function(message, source, lineno, colno, error) {
  logError(message, source, lineno, colno, error);
  return true;
};

// Функция для генерации лога и скачивания файла Log.txt
function generateErrorLog() {
  try {
    if (errorLogs.length === 0) {
      errorLogs.push(`[${getCurrentTimestamp()}] No errors reported.\n`);
    }
    const logText = errorLogs.join('\n');
    const blob = new Blob([logText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'Log.txt';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (e) {
    logError(e.message, "generateErrorLog", e.lineNumber, e.columnNumber, e);
  }
}

  function initEventListeners() {
      const addListener = (id, event, handler) => {
          const el = document.getElementById(id);
          if(el) el.addEventListener(event, handler);
          else console.error(`Element #${id} not found`);
      };

      addListener('decrease-length', 'click', () => adjustLength(-1));
      addListener('increase-length', 'click', () => adjustLength(1));
      addListener('copy-btn', 'click', copyToClipboard);
      addListener('clear-btn', 'click', cleanOutput);
      addListener('report-btn', 'click', generateErrorLog);
  }

  // Функция копирования в буфер
  function copyToClipboard() {
      navigator.clipboard.writeText(document.getElementById('output-content').textContent)
          .then(() => alert('Текст скопирован!'))
          .catch(err => console.error('Ошибка копирования:', err));
  }

  // Привязываем обработчик для кнопки "Репорт" после загрузки DOM
  document.addEventListener("DOMContentLoaded", function() {
      initEventListeners();
      updateOutput();
  });

  // Остальной код (обработка блоков, изменение длины строки, форматирование и т.д.) остается без изменений.
  // Пример: функция cleanOutput обёрнута в try/catch для логирования ошибок

  function cleanOutput() {
      const outputEl = document.getElementById('output-content');
      try {
          let content = outputEl.textContent
              .replace(/"\s*],/g, '"\n  ],')
              .replace(/\],\n\s+\[/g, '],\n  [')
              .replace(/(\d+ => \[)\n\s+\[/g, '$1\n  [[')
              .replace(/(\s{2}\][^\n]*)\n\s+(\][^\n]*)/g, '$1$2')
              .replace(/\[\[\n\s+\[/g, '[[\n  [')
              .replace(/"\s+\[/g, '", [');

          outputEl.textContent = content
              .split('\n')
              .map(line => line.trim().startsWith('"') 
                  ? line.replace(/^\s+/, '    ') 
                  : line
              )
              .join('\n');
          
          isFormatted = true;
      } catch(e) {
          logError(e.message, "cleanOutput", e.lineNumber, e.columnNumber, e);
      }
  }


  // Пример использования: оборачиваем функцию очистки вывода в try/catch
  function cleanOutput() {
    try {
      const outputEl = document.getElementById('output-content');
      let lines = outputEl.textContent.split('\n');
      let newLines = [];
      let inBlock = false;
      let prevLine = '';
      
      // Track categories and indentation states
      const categories = ["Экипировка:", "Навыки:", "Способности:"];
      let currentCategory = "";
      const indent = "			   "; // Standard indentation for continuation lines
      
      for(let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmedLine = line.trim();
        
        // Check if we're at the start or end of a block
        if(trimmedLine === '[[') {
            newLines.push(line);
            inBlock = true;
            i++; // Skip the next line after [[
            continue;
        }
        
        if(trimmedLine === ']],') {
            if(prevLine.trim() === '],') {
                newLines.pop(); // Remove the second-to-last line before ]],
            }
            newLines.push(line);
            inBlock = false;
            currentCategory = "";
            continue;
        }
        
        if(inBlock) prevLine = line;
        
        // Check if line contains a category
        let isCategoryLine = false;
        for(let category of categories) {
            if(trimmedLine.startsWith(category)) {
                currentCategory = category;
                isCategoryLine = true;
                break;
            }
        }
        
        // Process the line based on content type
        if(isCategoryLine) {
            // This is a category header line - clean it but keep as is
            let cleanedLine = trimmedLine.replace(/\s*　\s*/g, '　');
            newLines.push(cleanedLine);
            
        } else if(currentCategory && !isCategoryLine) {
            // This is a continuation of a category - apply indentation
            
            // If line starts with wide space or has indentation already
            let content = trimmedLine;
            if(content.startsWith('　')) {
                content = content.substring(1);
            }
            
            // Clean spaces around wide spaces
            content = content.replace(/\s*　\s*/g, '　');
            
            // Apply proper indentation
            newLines.push(indent + content);
            
        } else {
            // Regular line - just clean it
            let cleanedLine = trimmedLine.replace(/\s*　\s*/g, '　');
            newLines.push(cleanedLine);
        }
      }
      
      outputEl.textContent = newLines.join('\n');
      isFormatted = true;
    } catch (e) {
      logError(e.message, "cleanOutput", e.lineNumber, e.columnNumber, e);
    }
  }


  // Единая функция изменения длины строки, учитывающая текущую вкладку
  function adjustLength(delta) {
    if (currentTab === "jobchange") {
      maxLineLengthJobChangeVar = Math.max(10, maxLineLengthJobChangeVar + delta);
    } else if (currentMode === "JAP") {
      maxLineLengthJap = Math.max(10, maxLineLengthJap + delta);
    } else {
      maxLineLengthRus = Math.max(10, maxLineLengthRus + delta);
    }

  // Если формат уже исправлен, корректируем перед обновлением
    if (isFormatted) {
      fixFormatting();
    }

    updateOutput(); // Вызываем обновление после исправления
  }


  // Единая функция обновления отображения длины строки
  function updateLengthDisplay() {
    let len;
    if (currentTab === "jobchange") {
      len = maxLineLengthJobChangeVar;
    } else {
      len = currentMode === "JAP" ? maxLineLengthJap : maxLineLengthRus;
    }
    document.getElementById('current-length').textContent = len;
  }

  // Единая функция обновления вывода
  // Функция обновления вывода
  function updateOutput() {
    updateLengthDisplay();
    const inputText = document.getElementById('input-data').value;
    if (!inputText.trim()) {
      document.getElementById('output-content').textContent = '';
      return;
    }
    try {
      let output = currentTab === "library" ? processText(inputText) : processJobChangeText(inputText);
      document.getElementById('output-content').textContent = output;
    } catch (e) {
      document.getElementById('output-content').textContent = 'Ошибка форматирования';
    }
  }

  // Функция обработки JobChange
  function processJobChangeText(text) {
      try {
          // Parse input into blocks
          let lines = text.split('\n');
          let blocks = [];
          let currentBlock = null;
          
          for (let line of lines) {
              if (line.trim().match(/^\d+\s*#/)) {
                  if (currentBlock) blocks.push(currentBlock);
                  currentBlock = { 
                      header: line.trim(), 
                      description: [],
                      equipment: []
                  };
              } else if (currentBlock) {
                  // Check if this is an equipment/skills/abilities line
                  if (line.trim().startsWith('Экипировка:') || 
                      line.trim().startsWith('Навыки:') || 
                      line.trim().startsWith('Способности:')) {
                      currentBlock.equipment.push(line.trim());
                  } else if (currentBlock.equipment.length > 0) {
                      // If we've already started equipment section, keep adding to it
                      currentBlock.equipment.push(line.trim());
                  } else {
                      // Otherwise, it's part of the description
                      currentBlock.description.push(line.trim());
                  }
              }
          }
          
          if (currentBlock) blocks.push(currentBlock);
          
          if (blocks.length === 0) return ""; // No blocks found
          
          let result = "";
          blocks.forEach(block => {
              // Extract ID and title from header
              let headerParts = block.header.split('#');
              let id = headerParts[0].trim();
              let title = headerParts.length > 1 ? '# ' + headerParts[1].trim() : '';
              
              // Format description
              let descriptionText = block.description.join(' ');
              let descriptionLines = wrapText(descriptionText, maxLineLengthJobChangeVar, currentMode);
              
              // Process equipment/skills/abilities lines
              let equipmentLines = [];
              
              // Group by categories
              let categoryGroups = {};
              let currentCategory = null;
              
              // First, group lines by category
              for (let line of block.equipment) {
                  if (line.startsWith('Экипировка:') || 
                      line.startsWith('Навыки:') || 
                      line.startsWith('Способности:')) {
                      
                      currentCategory = line.split(':')[0] + ':';
                      categoryGroups[currentCategory] = line.substring(currentCategory.length).trim();
                  } else if (currentCategory) {
                      categoryGroups[currentCategory] += ' ' + line.trim();
                  }
              }
              
              // Format each category
              for (let category in categoryGroups) {
                  let items = categoryGroups[category].split('　').filter(Boolean);
                  let currentLine = category + " ";
                  const indent = "			   "; // Standard indentation
                  
                  for (let item of items) {
                      if ((currentLine.length + item.length + 1) <= maxLineLengthJobChangeVar) {
                          currentLine += item + "　";
                      } else {
                          // Remove trailing wide space
                          if (currentLine.endsWith("　")) {
                              currentLine = currentLine.slice(0, -1);
                          }
                          equipmentLines.push(currentLine);
                          currentLine = indent + item + "　";
                      }
                  }
                  
                  // Add the last line for this category
                  if (currentLine !== category + " ") {
                      if (currentLine.endsWith("　")) {
                          currentLine = currentLine.slice(0, -1);
                      }
                      equipmentLines.push(currentLine);
                  }
              }
              
              // Build result with correct structure and SAVE marker
              result += `${id} => ${title}\n  [[\n`;
              
              // Description section
              descriptionLines.forEach(line => {
                  result += `    "${escapeQuotes(line)}",\n`;
              });
              
              // Add SAVE marker instead of ],[ section separator
              result += "SAVE\n";
              
              // Equipment section
              equipmentLines.forEach(line => {
                  result += `    "${escapeQuotes(line)}",\n`;
              });
              
              result += "  ]],\n";
          });
          
          return result;
      } catch (e) {
          console.error("Error in processJobChangeText:", e);
          throw e;
      }
  }

  // Вспомогательная функция для форматирования категорий
  function formatCategory(category, items, maxLineLength) {
      const indent = "			   "; // Стандартный отступ для продолжения строк
      let lines = [];
      let currentLine = category + " ";
      
      for (let item of items) {
          if (!item.trim()) continue;
          
          if ((currentLine.length + item.length + 1) <= maxLineLength) {
              currentLine += item + "　";
          } else {
              // Удаляем завершающий широкий пробел
              if (currentLine.endsWith("　")) {
                  currentLine = currentLine.slice(0, -1);
              }
              lines.push(currentLine);
              currentLine = indent + item + "　";
          }
      }
      
      // Добавляем последнюю строку, удаляя завершающий широкий пробел
      if (currentLine !== category + " " && currentLine !== indent) {
          if (currentLine.endsWith("　")) {
              currentLine = currentLine.slice(0, -1);
          }
          lines.push(currentLine);
      }
      
      return lines;
  }


  // Функция wrapText (перенос строк)
  function wrapText(text, maxLen, lang) {
      try {
          if (lang === "JAP") {
              // Japanese text: break by characters
              let lines = [];
              for (let i = 0; i < text.length; i += maxLen) {
                  lines.push(text.substr(i, maxLen));
              }
              return lines;
          } else {
              // Russian text: handle categories specifically
              const categories = ["Экипировка:", "Навыки:", "Способности:"];
              
              // Check if this is a category paragraph
              let isCategory = false;
              let categoryName = "";
              
              for (let cat of categories) {
                  if (text.startsWith(cat)) {
                      isCategory = true;
                      categoryName = cat;
                      break;
                  }
              }
              
              if (isCategory) {
                  // This is a category paragraph - special handling
                  let lines = [];
                  const indent = "			   "; // Standard indentation
                  
                  // Extract items after the category
                  let items = text.substring(categoryName.length).trim().split('　').filter(Boolean);
                  let currentLine = categoryName;
                  
                  for (let item of items) {
                      if ((currentLine.length + 1 + item.length + 1) <= maxLen) {
                          currentLine += (currentLine === categoryName ? " " : "　") + item;
                      } else {
                          lines.push(currentLine);
                          currentLine = indent + item;
                      }
                  }
                  
                  if (currentLine !== categoryName && currentLine !== indent) {
                      lines.push(currentLine);
                  }
                  
                  return lines;
              } else {
                  // Regular text paragraph - break by words
                  let words = text.split(' ');
                  let lines = [];
                  let currentLine = '';
                  
                  for (let word of words) {
                      if ((currentLine.length ? currentLine.length + 1 : 0) + word.length <= maxLen) {
                          currentLine += (currentLine ? ' ' : '') + word;
                      } else {
                          lines.push(currentLine);
                          currentLine = word;
                      }
                  }
                  
                  if (currentLine) {
                      lines.push(currentLine);
                  }
                  
                  return lines;
              }
          }
      } catch (e) {
          console.error("Error in wrapText:", e);
          return [text]; // Return original text as fallback
      }
  }

    

  // Функция экранирования кавычек в строке
  function escapeQuotes(str) {
    return str.replace(/"/g, '\\"');
  }

  // Функция обработки для вкладки Library (без изменений)
  function processText(text) {
    let lines = text.split('\n');
    let blocks = [];
    let currentBlock = null;
    for (let line of lines) {
      if (line.trim().match(/^\d+$/)) { // новая метка блока
        if (currentBlock) {
          blocks.push(currentBlock);
        }
        currentBlock = { id: line.trim(), content: [] };
      } else {
        if (currentBlock) {
          currentBlock.content.push(line);
        }
      }
    }
    if (currentBlock) {
      blocks.push(currentBlock);
    }
    return blocks.map(block => processBlock(block)).join('\n');
  }

  // Функция для проверки строки на наличие символов нужного языка
  function isLineInActiveLang(line) {
    if (currentMode === "RUS") {
      return /[А-Яа-яЁё]/.test(line);
    } else if (currentMode === "JAP") {
      return /[\u3040-\u30FF\u4E00-\u9FBF]/.test(line);
    }
    return false;
  }

  // Обрабатывает отдельный блок для Library
  function processBlock(block) {
      let outputLines = [];
      let illustrationLine = "";
      
      function addLine(line) {
          if (line === "") {
              if (outputLines.length === 0 || outputLines[outputLines.length - 1] !== "") {
                  outputLines.push("");
              }
          } else {
              outputLines.push(line);
          }
      }
      
      block.content.forEach(line => {
          if (line.trim() === "") {
              addLine("");
              return;
          }
          if (line.trim().match(/^Иллюстрация[:：]/)) {
              illustrationLine = line.trim();
              return;
          }
          if (isLineInActiveLang(line)) {
              let splitted = splitIntoLines(line, getCurrentMaxLineLength());
              splitted.forEach(subLine => addLine(subLine));
          }
      });
      
      if (illustrationLine) {
          illustrationLine = illustrationLine.replace(/^Иллюстрация[:：]\s*/, "");
          if (currentMode === "JAP") {
              illustrationLine = illustrationPrefixJAP + illustrationLine;
          } else {
              illustrationLine = illustrationPrefixRUS + " " + illustrationLine;
          }
          addLine("");
          addLine(illustrationLine);
      }
      
      let formatted = outputLines.map(line => `    "${escapeQuotes(line)}",`).join('\n');
      // Исправлено формирование структуры блоков
      return `${block.id} => [\n${formatted}\n],`;
  }

  // Разбивка текста на строки с учётом максимальной длины для Library
  function splitIntoLines(text, maxLen) {
    if (currentMode === "JAP") {
      let lines = [];
      for (let i = 0; i < text.length; i += maxLen) {
        lines.push(text.substr(i, maxLen));
      }
      return lines;
    } else {
      const words = text.replace(/\n/g, ' ').split(' ').filter(Boolean);
      let lines = [];
      let currentLine = '';
      words.forEach(word => {
        if ((currentLine.length ? currentLine.length + 1 : 0) + word.length > maxLen) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine += (currentLine ? ' ' : '') + word;
        }
      });
      if (currentLine) lines.push(currentLine);
      return lines;
    }
  }

  // Возвращает текущую максимальную длину строки для выбранного языка (для Library)
  function getCurrentMaxLineLength() {
    return currentMode === "JAP" ? maxLineLengthJap : maxLineLengthRus;
  }

  function fixFormatting() {
      try {
          const outputEl = document.getElementById('output-content');
          let content = outputEl.textContent;
          
          // Replace SAVE marker with proper section separator
          content = content.replace(/SAVE/g, '  ],\n  [');
          
          // Fix any other formatting issues
          let lines = content.split('\n');
          let result = [];
          
          for (let i = 0; i < lines.length; i++) {
              let line = lines[i].trim();
              
              // Skip empty lines
              if (line === '') continue;
              
              // Process lines based on content
              if (line.match(/^\d+\s*=>\s*#/)) {
                  // Block header - add as is
                  result.push(line);
              } else if (line === '[[') {
                  // Block start - add with proper indentation
                  result.push('  [[');
              } else if (line === ']],') {
                  // Block end - add with proper indentation
                  result.push('  ]],');
              } else if (line.startsWith('"')) {
                  // Quoted line - add with proper indentation
                  result.push('    ' + line);
              } else if (line === '],') {
                  // Section end - add with proper indentation
                  result.push('  ],');
              } else if (line === '[') {
                  // Section start - add with proper indentation
                  result.push('  [');
              } else {
                  // Other lines - add as is
                  result.push(line);
              }
          }
          
          outputEl.textContent = result.join('\n');
          isFormatted = true;
      } catch (e) {
          console.error("Error in fixFormatting:", e);
          alert("Error in fixFormatting: " + e.message);
      }
  }

  // Изменение длины строки (и сохранение формата)
  function adjustLength(delta) {
    if (currentTab === "jobchange") {
      maxLineLengthJobChangeVar = Math.max(10, maxLineLengthJobChangeVar + delta);
    } else if (currentMode === "JAP") {
      maxLineLengthJap = Math.max(10, maxLineLengthJap + delta);
    } else {
      maxLineLengthRus = Math.max(10, maxLineLengthRus + delta);
    }

    // Если формат уже исправлен, переформатируем с учётом исправлений
    if (isFormatted) fixFormatting();
    updateOutput();
  }

  // Обработчики кнопок
  document.getElementById('decrease-length').addEventListener('click', () => adjustLength(-1));
  document.getElementById('increase-length').addEventListener('click', () => adjustLength(1));
  document.getElementById('copy-btn').addEventListener('click', () => {
    navigator.clipboard.writeText(document.getElementById('output-content').textContent)
      .then(() => alert('Текст скопирован!'))
      .catch(err => console.error('Ошибка копирования:', err));
  });
  document.getElementById('clear-btn').addEventListener('click', fixFormatting);
  document.addEventListener("DOMContentLoaded", function () {
  const reportBtn = document.getElementById("report-btn");
  if (reportBtn) {
    reportBtn.addEventListener("click", generateErrorLog);
  } else {
    console.warn("Кнопка 'Репорт' (report-btn) не найдена в HTML!");
  }
});

  // Инициализация
  updateOutput();

// --- Упрощённая функция очистки вывода ---
  function cleanOutput() {
      const outputEl = document.getElementById('output-content');
      let lines = outputEl.textContent.split('\n');
      let newLines = [];
      let inBlock = false;
      let prevLine = '';
      
      // Track categories and indentation states
      const categories = ["Экипировка:", "Навыки:", "Способности:"];
      let currentCategory = "";
      const indent = "			   "; // Standard indentation for continuation lines
      
      for(let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const trimmedLine = line.trim();
          
          // Check if we're at the start or end of a block
          if(trimmedLine === '[[') {
              newLines.push(line);
              inBlock = true;
              i++; // Skip the next line after [[
              continue;
          }
          
          if(trimmedLine === ']],') {
              if(prevLine.trim() === '],') {
                  newLines.pop(); // Remove the second-to-last line before ]],
              }
              newLines.push(line);
              inBlock = false;
              currentCategory = "";
              continue;
          }
          
          if(inBlock) prevLine = line;
          
          // Check if line contains a category
          let isCategoryLine = false;
          for(let category of categories) {
              if(trimmedLine.startsWith(category)) {
                  currentCategory = category;
                  isCategoryLine = true;
                  break;
              }
          }
          
          // Process the line based on content type
          if(isCategoryLine) {
              // This is a category header line - clean it but keep as is
              let cleanedLine = trimmedLine.replace(/\s*　\s*/g, '　');
              newLines.push(cleanedLine);
              
          } else if(currentCategory && !isCategoryLine) {
              // This is a continuation of a category - apply indentation
              
              // If line starts with wide space or has indentation already
              let content = trimmedLine;
              if(content.startsWith('　')) {
                  content = content.substring(1);
              }
              
              // Clean spaces around wide spaces
              content = content.replace(/\s*　\s*/g, '　');
              
              // Apply proper indentation
              newLines.push(indent + content);
              
          } else {
              // Regular line - just clean it
              let cleanedLine = trimmedLine.replace(/\s*　\s*/g, '　');
              newLines.push(cleanedLine);
          }
      }
      
      outputEl.textContent = newLines.join('\n');
      isFormatted = true;
  }
</script>
</body>
</html>
